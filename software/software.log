KCPSM6 Assembler log file for program 'C:\Users\thile\Dropbox\School Work\EE 178\Labs\Lab 8\group2_lab8\software\software.psm'.
Generated by KCPSM6 version v2.51
Ken Chapman - Xilinx Ltd - 29th May 2013

Assembly datestamp: 28 Nov 2016
Assembly timestamp: 22:34:40

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 7FF hex
Nominal program memory size: 2K (2048)   address(10:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 384
Memory locations available: 3712


Assembly listing

 Addr Code                  Instruction

 000                        ;;============================================================================
 000                        ;; File: software.psm
 000                        ;; This is the PicoBlaze example game program for EE178 Lab #8.
 000                        ;; No guarantee this is bug-free but it is a playable example.
 000                        ;;============================================================================
 000                        ;;============================================================================
 000                        ;; Ports and related constants.
 000                        ;;============================================================================
 000                        CONSTANT stax, 00                          ; port for 8-bit start-x
 000                        CONSTANT stay, 01                          ; port for 8-bit start-y
 000                        CONSTANT endx, 02                          ; port for 8-bit end-x
 000                        CONSTANT endy, 03                          ; port for 8-bit end-y
 000                        CONSTANT busy, 04                          ; port for 8-bit busy
 000                        CONSTANT beam, 05                          ; port for 8-bit beam
 000                        CONSTANT mode, 06                          ; port for 8-bit mode
 000                        CONSTANT prng, 07                          ; port for 8-bit prng
 000                        CONSTANT leds_lo, 08                       ; port for 8-bit led data out
 000                        CONSTANT leds_hi, 09                       ; port for 8-bit led data out
 000                        CONSTANT qssd_lo, 0A                       ; port for 8-bit qssd data out
 000                        CONSTANT qssd_hi, 0B                       ; port for 8-bit qssd data out
 000                        CONSTANT qssd_dp, 0C                       ; port for 8-bit qssd data out
 000                        CONSTANT switches_lo, 0D                   ; port for 8-bit switch input
 000                        CONSTANT switches_hi, 0E                   ; port for 8-bit switch input
 000                        CONSTANT buttons, 0F                       ; port for 8-bit button input
 000                        CONSTANT busy_go, 01                       ; go command and busy status
 000                        CONSTANT beam_hi, 0F                       ; beam high intensity
 000                        CONSTANT beam_md, 07                       ; beam med intensity
 000                        CONSTANT beam_lo, 03                       ; beam low intensity
 000                        CONSTANT mode_hld, 00                      ; mode hold framebuffer
 000                        CONSTANT mode_clr, 01                      ; mode clear framebuffer
 000                        CONSTANT mode_lin, 02                      ; mode linear decay
 000                        CONSTANT mode_exp, 03                      ; mode exponential decay
 000                        CONSTANT buttons_ct, 10                    ; center
 000                        CONSTANT buttons_up, 08                    ; up
 000                        CONSTANT buttons_dn, 04                    ; down
 000                        CONSTANT buttons_lf, 02                    ; left
 000                        CONSTANT buttons_rt, 01                    ; right
 000                        ;;============================================================================
 000                        ;; Game state declarations.
 000                        ;;============================================================================
 000                        NAMEREG s0, gs_major
 000                        CONSTANT gs_major_attrone, 00              ; state assignment
 000                        CONSTANT gs_major_attrtwo, 01              ; state assignment
 000                        CONSTANT gs_major_playing, 02              ; state assignment
 000                        CONSTANT gs_major_gameend, 03              ; state assignment
 000                        NAMEREG s1, gs_minor
 000                        CONSTANT gs_minor_begins, 00               ; counter initialize
 000                        CONSTANT gs_minor_twosec, 78               ; frame count about 2.0 secs
 000                        CONSTANT gs_minor_onesec, 3C               ; frame count about 1.0 secs
 000                        CONSTANT gs_minor_getrdy, 1E               ; frame count about 0.5 secs
 000                        NAMEREG s2, gs_ballx
 000                        NAMEREG s3, gs_bally
 000                        NAMEREG s4, gs_balldx
 000                        NAMEREG s5, gs_balldy
 000                        CONSTANT gs_ball_xdim, 08                  ; it's this plus 1
 000                        CONSTANT gs_ball_ydim, 08                  ; it's this plus 1
 000                        CONSTANT gs_ball_speed, 03                 ; pixels per frame
 000                        NAMEREG s6, gs_padlx
 000                        CONSTANT gs_padly, D0                      ; paddle y location
 000                        CONSTANT gs_padl_xdim, 20                  ; it's this plus 1
 000                        CONSTANT gs_padl_ydim, 08                  ; it's this plus 1
 000                        CONSTANT gs_padl_speed, 04                 ; pixels per frame
 000                        ;;============================================================================
 000                        ;; Global variables.
 000                        ;;============================================================================
 000                        NAMEREG s7, resvd1                         ; reserved
 000                        NAMEREG s8, resvd2                         ; reserved
 000                        NAMEREG s9, xpos                           ; for drawing routines
 000                        NAMEREG sA, ypos                           ; for drawing routines
 000                        NAMEREG sB, swlsamp                        ; switch lo sample
 000                        NAMEREG sC, swhsamp                        ; switch hi sample
 000                        NAMEREG sD, btnsamp                        ; button sample
 000                        NAMEREG sE, loopvar                        ; for loops
 000                        NAMEREG sF, scratch                        ; for scratch
 000                        ;;============================================================================
 000                        ;; Other stuff.
 000                        ;;============================================================================
 000                        CONSTANT minusone, FF                      ; minusone
 000                        CONSTANT minusmax, 80                      ; minus 128
 000                        CONSTANT plusmax, 7F                       ; plus 127
 000                        CONSTANT zero, 00                          ; zero
 000                        CONSTANT one, 01                           ; one
 000                        ;;============================================================================
 000                        ;; Boot.
 000                        ;; This performs one-time initialization of the hardware and the game state.
 000                        ;;============================================================================
 000  20008           boot: CALL 008[hw_init]                          ; initial hardware setup
 001  20016                 CALL 016[gs_init]                          ; set initial game state
 002  28001                 ENABLE INTERRUPT                           ; enable vblnk interrupt
 003                        ;;============================================================================
 003                        ;; Main.
 003                        ;; This is an empty loop, does nothing, waiting for interrupts to occur.
 003                        ;;============================================================================
 003  22003           main: JUMP 003[main]                             ; empty loop, does nothing
 004                        ;;============================================================================
 004                        ;; Interrupt.
 004                        ;; This is the main game logic.  At each interrupt, the procedure is to read
 004                        ;; the user input, calculate the next game state, and then draw the game
 004                        ;; state on the display.
 004                        ;;============================================================================
 004  2001E            isr: CALL 01E[user_input]                       ; get the user input
 005  2002A                 CALL 02A[calc_next_gs]                     ; calculate next state
 006  200AB                 CALL 0AB[draw_gs]                          ; draw the state
 007  29001                 RETURNI ENABLE                             ; return with enable
 008                        ;;============================================================================
 008                        ;; Subroutine: hw_init
 008                        ;; This puts the hardware into a known, initial state.  This includes a wait
 008                        ;; to make sure the line drawing harware is idle (a wait loop which is also
 008                        ;; called from other routines, as a subroutine).
 008                        ;;============================================================================
 008  01F00        hw_init: LOAD sF[scratch], 00[zero]                 ; going to use lot of zero
 009  2DF08                 OUTPUT sF[scratch], 08[leds_lo]            ; turn off lo leds
 00A  2DF09                 OUTPUT sF[scratch], 09[leds_hi]            ; turn off hi leds
 00B  2DF0A                 OUTPUT sF[scratch], 0A[qssd_lo]            ; zeroize qssd lo
 00C  2DF0B                 OUTPUT sF[scratch], 0B[qssd_hi]            ; zeroize qssd hi
 00D  2DF0C                 OUTPUT sF[scratch], 0C[qssd_dp]            ; turn off qssd dots
 00E  01F03                 LOAD sF[scratch], 03[mode_exp]             ; load desired mode
 00F  2DF06                 OUTPUT sF[scratch], 06[mode]               ; program the framebuffer
 010  01F0F                 LOAD sF[scratch], 0F[beam_hi]              ; load desired beam
 011  2DF05                 OUTPUT sF[scratch], 05[beam]               ; program the framebuffer
 012  09F04   hw_init_wait: INPUT sF[scratch], 04[busy]                ; get framebuffer busy
 013  1DF01                 COMPARE sF[scratch], 01[busy_go]           ; check framebuffer busy
 014  32012                 JUMP Z, 012[hw_init_wait]                  ; back to wait if busy
 015  25000                 RETURN                                     ; return
 016                        ;;============================================================================
 016                        ;; Subroutine: gs_init
 016                        ;; This puts the game into a known, initial state.  I've assigned all of the
 016                        ;; game state to a known value -- although some of these assignments do not
 016                        ;; really matter based on design of the game state machine.
 016                        ;;============================================================================
 016  01000        gs_init: LOAD s0[gs_major], 00[gs_major_attrone]    ; start in attract mdoe
 017  01100                 LOAD s1[gs_minor], 00[gs_minor_begins]     ; start with counter zero
 018  01200                 LOAD s2[gs_ballx], 00[zero]                ; doesn't really matter
 019  01300                 LOAD s3[gs_bally], 00[zero]                ; doesn't really matter
 01A  01600                 LOAD s6[gs_padlx], 00[zero]                ; doesn't really matter
 01B  01400                 LOAD s4[gs_balldx], 00[zero]               ; doesn't really matter
 01C  01500                 LOAD s5[gs_balldy], 00[zero]               ; doesn't really matter
 01D  25000                 RETURN                                     ; return
 01E                        ;;============================================================================
 01E                        ;; Subroutine: user_input
 01E                        ;; This samples the user inputs required for this game (which happens to be
 01E                        ;; only the buttons, but this could is extended to the switches as well).
 01E                        ;; This subroutine calls an example of how to use the RAM scratchpad, by
 01E                        ;; implementing access of a 256x8 array using switches, button, and qssd.
 01E                        ;; The call to the ram_example routine (and ram_example routine itself)
 01E                        ;; can be entirely removed as it is not needed in this game.
 01E                        ;;============================================================================
 01E  09D0F     user_input: INPUT sD[btnsamp], 0F[buttons]             ; sample button hardware
 01F  09B0D                 INPUT sB[swlsamp], 0D[switches_lo]         ; sample switch lo hardware
 020  09C0E                 INPUT sC[swhsamp], 0E[switches_hi]         ; sample switch hi hardware
 021  20023                 CALL 023[ram_example]                      ; do the ram example
 022  25000                 RETURN                                     ; return
 023  2DC0B    ram_example: OUTPUT sC[swhsamp], 0B[qssd_hi]            ; display ram address
 024  0AFC0                 FETCH sF[scratch], (sC[swhsamp])           ; read the ram at addr
 025  2DF0A                 OUTPUT sF[scratch], 0A[qssd_lo]            ; display data from ram
 026  0DD04                 TEST sD[btnsamp], 04[buttons_dn]           ; does user want to write
 027  31000                 RETURN Z                                   ; if not then return
 028  2EBC0                 STORE sB[swlsamp], (sC[swhsamp])           ; write the ram at addr
 029  25000                 RETURN                                     ; return
 02A                        ;;============================================================================
 02A                        ;; Subroutine: calc_next_gs
 02A                        ;; This logic calculates the next state of the game, given the sampled user
 02A                        ;; inputs and the current state of the game.
 02A                        ;;============================================================================
 02A  1D000   calc_next_gs: COMPARE s0[gs_major], 00[gs_major_attrone] ; are we in attrone?
 02B  32033                 JUMP Z, 033[calc_attrone]                  ; do ns calc for attrone
 02C  1D001                 COMPARE s0[gs_major], 01[gs_major_attrtwo] ; are we in attrtwo?
 02D  32039                 JUMP Z, 039[calc_attrtwo]                  ; do ns calc for attrtwo
 02E  1D002                 COMPARE s0[gs_major], 02[gs_major_playing] ; are we in playing?
 02F  3203F                 JUMP Z, 03F[calc_playing]                  ; do ns calc for playing
 030  1D003                 COMPARE s0[gs_major], 03[gs_major_gameend] ; are we in gameend?
 031  32082                 JUMP Z, 082[calc_gameend]                  ; do ns calc for gameend
 032  25000                 RETURN                                     ; return
 033  0DD10   calc_attrone: TEST sD[btnsamp], 10[buttons_ct]
 034  3608C                 JUMP NZ, 08C[goto_playing]
 035  1D178                 COMPARE s1[gs_minor], 78[gs_minor_twosec]
 036  32089                 JUMP Z, 089[goto_attrtwo]
 037  11101                 ADD s1[gs_minor], 01[one]
 038  25000                 RETURN 
 039  0DD10   calc_attrtwo: TEST sD[btnsamp], 10[buttons_ct]
 03A  3608C                 JUMP NZ, 08C[goto_playing]
 03B  1D13C                 COMPARE s1[gs_minor], 3C[gs_minor_onesec]
 03C  32086                 JUMP Z, 086[goto_attrone]
 03D  11101                 ADD s1[gs_minor], 01[one]
 03E  25000                 RETURN 
 03F  20049   calc_playing: CALL 049[upd_padl]
 040  1D11E                 COMPARE s1[gs_minor], 1E[gs_minor_getrdy]
 041  3E044                 JUMP NC, 044[goplay]
 042  11101         getrdy: ADD s1[gs_minor], 01[one]
 043  25000                 RETURN 
 044  2005E         goplay: CALL 05E[upd_ball]
 045  1D500                 COMPARE s5[gs_balldy], 00[zero]
 046  1F400                 COMPARECY s4[gs_balldx], 00[zero]
 047  320A8                 JUMP Z, 0A8[goto_gameend]
 048  25000                 RETURN 
 049  01F00       upd_padl: LOAD sF[scratch], 00[zero]
 04A  0DD02                 TEST sD[btnsamp], 02[buttons_lf]
 04B  1BF00                 SUBCY sF[scratch], 00[zero]
 04C  0DD01                 TEST sD[btnsamp], 01[buttons_rt]
 04D  13F00                 ADDCY sF[scratch], 00[zero]
 04E  1DFFF                 COMPARE sF[scratch], FF[minusone]
 04F  30053                 CALL Z, 053[upd_padl_lt]
 050  1DF01                 COMPARE sF[scratch], 01[one]
 051  30057                 CALL Z, 057[upd_padl_rt]
 052  25000                 RETURN 
 053  19604    upd_padl_lt: SUB s6[gs_padlx], 04[gs_padl_speed]
 054  3D000                 RETURN NC
 055  01600                 LOAD s6[gs_padlx], 00[zero]
 056  25000                 RETURN 
 057  11604    upd_padl_rt: ADD s6[gs_padlx], 04[gs_padl_speed]
 058  00F60                 LOAD sF[scratch], s6[gs_padlx]
 059  11F20                 ADD sF[scratch], 20[gs_padl_xdim]
 05A  3D000                 RETURN NC
 05B  016FF                 LOAD s6[gs_padlx], FF[minusone]
 05C  19620                 SUB s6[gs_padlx], 20[gs_padl_xdim]
 05D  25000                 RETURN 
 05E  01E03       upd_ball: LOAD sE[loopvar], 03[gs_ball_speed]
 05F  19E01  upd_ball_loop: SUB sE[loopvar], 01[one]
 060  39000                 RETURN C
 061  10240  upd_ball_step: ADD s2[gs_ballx], s4[gs_balldx]
 062  10350                 ADD s3[gs_bally], s5[gs_balldy]
 063  01FD0  upd_ball_padl: LOAD sF[scratch], D0[gs_padly]
 064  19F08                 SUB sF[scratch], 08[gs_ball_ydim]
 065  1C3F0                 COMPARE s3[gs_bally], sF[scratch]
 066  36070                 JUMP NZ, 070[upd_ball_lw]
 067  00F20                 LOAD sF[scratch], s2[gs_ballx]
 068  11F08                 ADD sF[scratch], 08[gs_ball_xdim]
 069  1CF60                 COMPARE sF[scratch], s6[gs_padlx]
 06A  3A070                 JUMP C, 070[upd_ball_lw]
 06B  00F60                 LOAD sF[scratch], s6[gs_padlx]
 06C  11F20                 ADD sF[scratch], 20[gs_padl_xdim]
 06D  1CF20                 COMPARE sF[scratch], s2[gs_ballx]
 06E  3A070                 JUMP C, 070[upd_ball_lw]
 06F  015FF                 LOAD s5[gs_balldy], FF[minusone]
 070  1D200    upd_ball_lw: COMPARE s2[gs_ballx], 00[zero]
 071  36073                 JUMP NZ, 073[upd_ball_tw]
 072  01401                 LOAD s4[gs_balldx], 01[one]
 073  1D300    upd_ball_tw: COMPARE s3[gs_bally], 00[zero]
 074  36076                 JUMP NZ, 076[upd_ball_rw]
 075  01501                 LOAD s5[gs_balldy], 01[one]
 076  01FFF    upd_ball_rw: LOAD sF[scratch], FF[minusone]
 077  19F08                 SUB sF[scratch], 08[gs_ball_xdim]
 078  1C2F0                 COMPARE s2[gs_ballx], sF[scratch]
 079  3607B                 JUMP NZ, 07B[upd_ball_bw]
 07A  014FF                 LOAD s4[gs_balldx], FF[minusone]
 07B  01FFF    upd_ball_bw: LOAD sF[scratch], FF[minusone]
 07C  19F08                 SUB sF[scratch], 08[gs_ball_ydim]
 07D  1C3F0                 COMPARE s3[gs_bally], sF[scratch]
 07E  36081                 JUMP NZ, 081[upd_ball_done]
 07F  01500                 LOAD s5[gs_balldy], 00[zero]
 080  01400                 LOAD s4[gs_balldx], 00[zero]
 081  2205F  upd_ball_done: JUMP 05F[upd_ball_loop]
 082  1D13C   calc_gameend: COMPARE s1[gs_minor], 3C[gs_minor_onesec]
 083  32086                 JUMP Z, 086[goto_attrone]
 084  11101                 ADD s1[gs_minor], 01[one]
 085  25000                 RETURN 
 086  01000   goto_attrone: LOAD s0[gs_major], 00[gs_major_attrone]
 087  01100                 LOAD s1[gs_minor], 00[gs_minor_begins]
 088  25000                 RETURN 
 089  01001   goto_attrtwo: LOAD s0[gs_major], 01[gs_major_attrtwo]
 08A  01100                 LOAD s1[gs_minor], 00[gs_minor_begins]
 08B  25000                 RETURN 
 08C  01002   goto_playing: LOAD s0[gs_major], 02[gs_major_playing]
 08D  01100                 LOAD s1[gs_minor], 00[gs_minor_begins]
 08E                        ; get a seed for initial ballx
 08E  09207                 INPUT s2[gs_ballx], 07[prng]
 08F                        ; start ball somewhere in the
 08F                        ; horizontal center of screen
 08F  1420A                 SRX s2[gs_ballx]
 090  1420A                 SRX s2[gs_ballx]
 091  1127F                 ADD s2[gs_ballx], 7F[plusmax]
 092                        ; get a seed for initial bally
 092  09307                 INPUT s3[gs_bally], 07[prng]
 093                        ; start ball somewhere in the
 093                        ; vertical center of screen
 093  1430A                 SRX s3[gs_bally]
 094  1430A                 SRX s3[gs_bally]
 095  1137F                 ADD s3[gs_bally], 7F[plusmax]
 096                        ; start paddle at the horizontal
 096                        ; center of the screen
 096  01620                 LOAD s6[gs_padlx], 20[gs_padl_xdim]
 097  1460A                 SRX s6[gs_padlx]
 098  076FF                 XOR s6[gs_padlx], FF[minusone]
 099  11601                 ADD s6[gs_padlx], 01[one]
 09A  11680                 ADD s6[gs_padlx], 80[minusmax]
 09B                        ; initial direction for ballx
 09B                        ; desire to start at +1 or -1
 09B  09407      balldxsta: INPUT s4[gs_balldx], 07[prng]
 09C  0D480                 TEST s4[gs_balldx], 80[minusmax]
 09D  320A0                 JUMP Z, 0A0[balldxpos]
 09E  014FF      balldxneg: LOAD s4[gs_balldx], FF[minusone]
 09F  220A1                 JUMP 0A1[balldysta]
 0A0  01401      balldxpos: LOAD s4[gs_balldx], 01[one]
 0A1                        ; initial direction for bally
 0A1                        ; desire to start at +1 or -1
 0A1  09507      balldysta: INPUT s5[gs_balldy], 07[prng]
 0A2  0D580                 TEST s5[gs_balldy], 80[minusmax]
 0A3  320A6                 JUMP Z, 0A6[balldypos]
 0A4  015FF      balldyneg: LOAD s5[gs_balldy], FF[minusone]
 0A5  220A7                 JUMP 0A7[ballddone]
 0A6  01501      balldypos: LOAD s5[gs_balldy], 01[one]
 0A7  25000      ballddone: RETURN 
 0A8  01003   goto_gameend: LOAD s0[gs_major], 03[gs_major_gameend]
 0A9  01100                 LOAD s1[gs_minor], 00[gs_minor_begins]
 0AA  25000                 RETURN 
 0AB                        ;;============================================================================
 0AB                        ;; Subroutine: draw_gs
 0AB                        ;; This uses the current game state as input, and draws it on the display.
 0AB                        ;; This subroutine calls an example of how to output debug or diagnostic info
 0AB                        ;; using the leds.  The call to the draw_gs_debug routine (and draw_gs_debug
 0AB                        ;; routine itself) can be entirely remove as it is required to play the game.
 0AB                        ;;============================================================================
 0AB  200B5        draw_gs: CALL 0B5[draw_gs_debug]                    ; for debug info display
 0AC  1D000                 COMPARE s0[gs_major], 00[gs_major_attrone] ; are we in attrone?
 0AD  320B8                 JUMP Z, 0B8[draw_attrone]                  ; do drawing for attrone
 0AE  1D001                 COMPARE s0[gs_major], 01[gs_major_attrtwo] ; are we in attrtwo?
 0AF  320F5                 JUMP Z, 0F5[draw_attrtwo]                  ; do drawing for attrtwo
 0B0  1D002                 COMPARE s0[gs_major], 02[gs_major_playing] ; are we in playing?
 0B1  32111                 JUMP Z, 111[draw_playing]                  ; do drawing for playing
 0B2  1D003                 COMPARE s0[gs_major], 03[gs_major_gameend] ; are we in gameend?
 0B3  32138                 JUMP Z, 138[draw_gameend]                  ; do drawing for gameend
 0B4  25000                 RETURN                                     ; return
 0B5  2D009  draw_gs_debug: OUTPUT s0[gs_major], 09[leds_hi]           ; debug display on leds
 0B6  2D108                 OUTPUT s1[gs_minor], 08[leds_lo]           ; debug display on leds
 0B7  25000                 RETURN                                     ; return
 0B8  01928   draw_attrone: LOAD s9[xpos], 28                          ; draw letter b
 0B9  01A50                 LOAD sA[ypos], 50
 0BA  20172                 CALL 172[moveto]
 0BB  01928                 LOAD s9[xpos], 28
 0BC  01A90                 LOAD sA[ypos], 90
 0BD  20175                 CALL 175[drawto]
 0BE  01948                 LOAD s9[xpos], 48
 0BF  01A90                 LOAD sA[ypos], 90
 0C0  20175                 CALL 175[drawto]
 0C1  01948                 LOAD s9[xpos], 48
 0C2  01A70                 LOAD sA[ypos], 70
 0C3  20175                 CALL 175[drawto]
 0C4  01928                 LOAD s9[xpos], 28
 0C5  01A70                 LOAD sA[ypos], 70
 0C6  20175                 CALL 175[drawto]
 0C7  01958                 LOAD s9[xpos], 58                          ; draw letter o
 0C8  01A70                 LOAD sA[ypos], 70
 0C9  20172                 CALL 172[moveto]
 0CA  01958                 LOAD s9[xpos], 58
 0CB  01A90                 LOAD sA[ypos], 90
 0CC  20175                 CALL 175[drawto]
 0CD  01978                 LOAD s9[xpos], 78
 0CE  01A90                 LOAD sA[ypos], 90
 0CF  20175                 CALL 175[drawto]
 0D0  01978                 LOAD s9[xpos], 78
 0D1  01A70                 LOAD sA[ypos], 70
 0D2  20175                 CALL 175[drawto]
 0D3  01958                 LOAD s9[xpos], 58
 0D4  01A70                 LOAD sA[ypos], 70
 0D5  20175                 CALL 175[drawto]
 0D6  01988                 LOAD s9[xpos], 88                          ; draw letter n
 0D7  01A90                 LOAD sA[ypos], 90
 0D8  20172                 CALL 172[moveto]
 0D9  01988                 LOAD s9[xpos], 88
 0DA  01A70                 LOAD sA[ypos], 70
 0DB  20175                 CALL 175[drawto]
 0DC  019A8                 LOAD s9[xpos], A8
 0DD  01A70                 LOAD sA[ypos], 70
 0DE  20175                 CALL 175[drawto]
 0DF  019A8                 LOAD s9[xpos], A8
 0E0  01A90                 LOAD sA[ypos], 90
 0E1  20175                 CALL 175[drawto]
 0E2  019B8                 LOAD s9[xpos], B8                          ; draw letter g
 0E3  01AB0                 LOAD sA[ypos], B0
 0E4  20172                 CALL 172[moveto]
 0E5  019D8                 LOAD s9[xpos], D8
 0E6  01AB0                 LOAD sA[ypos], B0
 0E7  20175                 CALL 175[drawto]
 0E8  019D8                 LOAD s9[xpos], D8
 0E9  01A70                 LOAD sA[ypos], 70
 0EA  20175                 CALL 175[drawto]
 0EB  019B8                 LOAD s9[xpos], B8
 0EC  01A70                 LOAD sA[ypos], 70
 0ED  20175                 CALL 175[drawto]
 0EE  019B8                 LOAD s9[xpos], B8
 0EF  01A90                 LOAD sA[ypos], 90
 0F0  20175                 CALL 175[drawto]
 0F1  019D8                 LOAD s9[xpos], D8
 0F2  01A90                 LOAD sA[ypos], 90
 0F3  20175                 CALL 175[drawto]
 0F4  25000                 RETURN 
 0F5  01978   draw_attrtwo: LOAD s9[xpos], 78                          ; draw letter e
 0F6  01A90                 LOAD sA[ypos], 90
 0F7  20172                 CALL 172[moveto]
 0F8  01958                 LOAD s9[xpos], 58
 0F9  01A90                 LOAD sA[ypos], 90
 0FA  20175                 CALL 175[drawto]
 0FB  01958                 LOAD s9[xpos], 58
 0FC  01A70                 LOAD sA[ypos], 70
 0FD  20175                 CALL 175[drawto]
 0FE  01978                 LOAD s9[xpos], 78
 0FF  01A70                 LOAD sA[ypos], 70
 100  20175                 CALL 175[drawto]
 101  01958                 LOAD s9[xpos], 58
 102  01A90                 LOAD sA[ypos], 90
 103  20175                 CALL 175[drawto]
 104  019A8                 LOAD s9[xpos], A8                          ; draw letter c
 105  01A70                 LOAD sA[ypos], 70
 106  20172                 CALL 172[moveto]
 107  01988                 LOAD s9[xpos], 88
 108  01A70                 LOAD sA[ypos], 70
 109  20175                 CALL 175[drawto]
 10A  01988                 LOAD s9[xpos], 88
 10B  01A90                 LOAD sA[ypos], 90
 10C  20175                 CALL 175[drawto]
 10D  019A8                 LOAD s9[xpos], A8
 10E  01A90                 LOAD sA[ypos], 90
 10F  20175                 CALL 175[drawto]
 110  25000                 RETURN 
 111  00920   draw_playing: LOAD s9[xpos], s2[gs_ballx]                ; draw ball
 112  00A30                 LOAD sA[ypos], s3[gs_bally]
 113  20172                 CALL 172[moveto]
 114  00920                 LOAD s9[xpos], s2[gs_ballx]
 115  00A30                 LOAD sA[ypos], s3[gs_bally]
 116  11A08                 ADD sA[ypos], 08[gs_ball_ydim]
 117  20175                 CALL 175[drawto]
 118  00920                 LOAD s9[xpos], s2[gs_ballx]
 119  00A30                 LOAD sA[ypos], s3[gs_bally]
 11A  11908                 ADD s9[xpos], 08[gs_ball_xdim]
 11B  11A08                 ADD sA[ypos], 08[gs_ball_ydim]
 11C  20175                 CALL 175[drawto]
 11D  00920                 LOAD s9[xpos], s2[gs_ballx]
 11E  00A30                 LOAD sA[ypos], s3[gs_bally]
 11F  11908                 ADD s9[xpos], 08[gs_ball_xdim]
 120  20175                 CALL 175[drawto]
 121  00920                 LOAD s9[xpos], s2[gs_ballx]
 122  00A30                 LOAD sA[ypos], s3[gs_bally]
 123  20175                 CALL 175[drawto]
 124  00960                 LOAD s9[xpos], s6[gs_padlx]                ; draw padl
 125  01AD0                 LOAD sA[ypos], D0[gs_padly]
 126  20172                 CALL 172[moveto]
 127  00960                 LOAD s9[xpos], s6[gs_padlx]
 128  01AD0                 LOAD sA[ypos], D0[gs_padly]
 129  11A08                 ADD sA[ypos], 08[gs_padl_ydim]
 12A  20175                 CALL 175[drawto]
 12B  00960                 LOAD s9[xpos], s6[gs_padlx]
 12C  01AD0                 LOAD sA[ypos], D0[gs_padly]
 12D  11920                 ADD s9[xpos], 20[gs_padl_xdim]
 12E  11A08                 ADD sA[ypos], 08[gs_padl_ydim]
 12F  20175                 CALL 175[drawto]
 130  00960                 LOAD s9[xpos], s6[gs_padlx]
 131  01AD0                 LOAD sA[ypos], D0[gs_padly]
 132  11920                 ADD s9[xpos], 20[gs_padl_xdim]
 133  20175                 CALL 175[drawto]
 134  00960                 LOAD s9[xpos], s6[gs_padlx]
 135  01AD0                 LOAD sA[ypos], D0[gs_padly]
 136  20175                 CALL 175[drawto]
 137  25000                 RETURN 
 138  01948   draw_gameend: LOAD s9[xpos], 48                          ; draw letter d
 139  01A50                 LOAD sA[ypos], 50
 13A  20172                 CALL 172[moveto]
 13B  01948                 LOAD s9[xpos], 48
 13C  01A90                 LOAD sA[ypos], 90
 13D  20175                 CALL 175[drawto]
 13E  01928                 LOAD s9[xpos], 28
 13F  01A90                 LOAD sA[ypos], 90
 140  20175                 CALL 175[drawto]
 141  01928                 LOAD s9[xpos], 28
 142  01A70                 LOAD sA[ypos], 70
 143  20175                 CALL 175[drawto]
 144  01948                 LOAD s9[xpos], 48
 145  01A70                 LOAD sA[ypos], 70
 146  20175                 CALL 175[drawto]
 147  01958                 LOAD s9[xpos], 58                          ; draw letter o
 148  01A70                 LOAD sA[ypos], 70
 149  20172                 CALL 172[moveto]
 14A  01958                 LOAD s9[xpos], 58
 14B  01A90                 LOAD sA[ypos], 90
 14C  20175                 CALL 175[drawto]
 14D  01978                 LOAD s9[xpos], 78
 14E  01A90                 LOAD sA[ypos], 90
 14F  20175                 CALL 175[drawto]
 150  01978                 LOAD s9[xpos], 78
 151  01A70                 LOAD sA[ypos], 70
 152  20175                 CALL 175[drawto]
 153  01958                 LOAD s9[xpos], 58
 154  01A70                 LOAD sA[ypos], 70
 155  20175                 CALL 175[drawto]
 156  01988                 LOAD s9[xpos], 88                          ; draw letter n
 157  01A90                 LOAD sA[ypos], 90
 158  20172                 CALL 172[moveto]
 159  01988                 LOAD s9[xpos], 88
 15A  01A70                 LOAD sA[ypos], 70
 15B  20175                 CALL 175[drawto]
 15C  019A8                 LOAD s9[xpos], A8
 15D  01A70                 LOAD sA[ypos], 70
 15E  20175                 CALL 175[drawto]
 15F  019A8                 LOAD s9[xpos], A8
 160  01A90                 LOAD sA[ypos], 90
 161  20175                 CALL 175[drawto]
 162  019D8                 LOAD s9[xpos], D8                          ; draw letter e
 163  01A90                 LOAD sA[ypos], 90
 164  20172                 CALL 172[moveto]
 165  019B8                 LOAD s9[xpos], B8
 166  01A90                 LOAD sA[ypos], 90
 167  20175                 CALL 175[drawto]
 168  019B8                 LOAD s9[xpos], B8
 169  01A70                 LOAD sA[ypos], 70
 16A  20175                 CALL 175[drawto]
 16B  019D8                 LOAD s9[xpos], D8
 16C  01A70                 LOAD sA[ypos], 70
 16D  20175                 CALL 175[drawto]
 16E  019B8                 LOAD s9[xpos], B8
 16F  01A90                 LOAD sA[ypos], 90
 170  20175                 CALL 175[drawto]
 171  25000                 RETURN 
 172                        ;;============================================================================
 172                        ;; Subroutine: moveto and drawto
 172                        ;; The moveto routine uses the global variables xpos and ypos, and the drawto
 172                        ;; routine uses these global variables as well as the endpoint coordinates in
 172                        ;; the display controller.  Moveto simply copies xpos and ypos into endpoint
 172                        ;; coordinates in the display controller, it does not draw anything.  The
 172                        ;; drawto routine copies endpoint coordinates to startpoint coordinates (does
 172                        ;; not matter if the endpoint was from an actual draw, or simply an update
 172                        ;; by moveto) and then copies xpos and ypos into endpoint coordinates, then
 172                        ;; starts a linedraw.
 172                        ;;============================================================================
 172  2D902         moveto: OUTPUT s9[xpos], 02[endx]                  ; copy global to hardware
 173  2DA03                 OUTPUT sA[ypos], 03[endy]                  ; copy global to hardware
 174  25000                 RETURN                                     ; return
 175  09F02         drawto: INPUT sF[scratch], 02[endx]                ; read hardware
 176  2DF00                 OUTPUT sF[scratch], 00[stax]               ; write hardware
 177  2D902                 OUTPUT s9[xpos], 02[endx]                  ; copy global to hardware
 178  09F03                 INPUT sF[scratch], 03[endy]                ; read hardware
 179  2DF01                 OUTPUT sF[scratch], 01[stay]               ; write hardware
 17A  2DA03                 OUTPUT sA[ypos], 03[endy]                  ; copy global to hardware
 17B  01F01                 LOAD sF[scratch], 01[busy_go]              ; prepare the command
 17C  2DF04                 OUTPUT sF[scratch], 04[busy]               ; send the command
 17D  20012                 CALL 012[hw_init_wait]                     ; wait line draw done
 17E  25000                 RETURN                                     ; return
 17F                        ;;============================================================================
 17F                        ;; Interrupt - Vector.
 17F                        ;;============================================================================
 7FF                        ADDRESS 7FF                                ; must be located here
 7FF  22004     isr_vector: JUMP 004[isr]                              ; always jump to isr
 800                        ;;============================================================================
 800                        ;;
 800                        ;;============================================================================



List of PSM files that have been assembled

C:\Users\thile\Dropbox\School Work\EE 178\Labs\Lab 8\group2_lab8\software\software.psm



List of defined constants

 CONSTANT name     Value        Source PSM File

 timestamp_hours   22'd         
 timestamp_minutes 34'd         
 timestamp_seconds 40'd         
 datestamp_year    16'd         
 datestamp_month   11'd         
 datestamp_day     28'd         
 NUL               00           
 BEL               07           
 BS                08           
 HT                09           
 LF                0A           
 VT                0B           
 CR                0D           
 ESC               1B           
 DEL               7F           
 DCS               90           
 ST                9C           
 stax              00           software.psm
 stay              01           software.psm
 endx              02           software.psm
 endy              03           software.psm
 busy              04           software.psm
 beam              05           software.psm
 mode              06           software.psm
 prng              07           software.psm
 leds_lo           08           software.psm
 leds_hi           09           software.psm
 qssd_lo           0A           software.psm
 qssd_hi           0B           software.psm
 qssd_dp           0C           software.psm
 switches_lo       0D           software.psm
 switches_hi       0E           software.psm
 buttons           0F           software.psm
 busy_go           01           software.psm
 beam_hi           0F           software.psm
 beam_md           07           software.psm
 beam_lo           03           software.psm
 mode_hld          00           software.psm
 mode_clr          01           software.psm
 mode_lin          02           software.psm
 mode_exp          03           software.psm
 buttons_ct        10           software.psm
 buttons_up        08           software.psm
 buttons_dn        04           software.psm
 buttons_lf        02           software.psm
 buttons_rt        01           software.psm
 gs_major_attrone  00           software.psm
 gs_major_attrtwo  01           software.psm
 gs_major_playing  02           software.psm
 gs_major_gameend  03           software.psm
 gs_minor_begins   00           software.psm
 gs_minor_twosec   78           software.psm
 gs_minor_onesec   3C           software.psm
 gs_minor_getrdy   1E           software.psm
 gs_ball_xdim      08           software.psm
 gs_ball_ydim      08           software.psm
 gs_ball_speed     03           software.psm
 gs_padly          D0           software.psm
 gs_padl_xdim      20           software.psm
 gs_padl_ydim      08           software.psm
 gs_padl_speed     04           software.psm
 minusone          FF           software.psm
 minusmax          80           software.psm
 plusmax           7F           software.psm
 zero              00           software.psm
 one               01           software.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.51"        
 datestamp$        "28 Nov 2016"  
 timestamp$        "22:34:40"     



List of line labels

   Label           Addr  Source PSM File

 * boot            000   software.psm
   main            003   software.psm
   isr             004   software.psm
   hw_init         008   software.psm
   hw_init_wait    012   software.psm
   gs_init         016   software.psm
   user_input      01E   software.psm
   ram_example     023   software.psm
   calc_next_gs    02A   software.psm
   calc_attrone    033   software.psm
   calc_attrtwo    039   software.psm
   calc_playing    03F   software.psm
 * getrdy          042   software.psm
   goplay          044   software.psm
   upd_padl        049   software.psm
   upd_padl_lt     053   software.psm
   upd_padl_rt     057   software.psm
   upd_ball        05E   software.psm
   upd_ball_loop   05F   software.psm
 * upd_ball_step   061   software.psm
 * upd_ball_padl   063   software.psm
   upd_ball_lw     070   software.psm
   upd_ball_tw     073   software.psm
   upd_ball_rw     076   software.psm
   upd_ball_bw     07B   software.psm
   upd_ball_done   081   software.psm
   calc_gameend    082   software.psm
   goto_attrone    086   software.psm
   goto_attrtwo    089   software.psm
   goto_playing    08C   software.psm
 * balldxsta       09B   software.psm
 * balldxneg       09E   software.psm
   balldxpos       0A0   software.psm
   balldysta       0A1   software.psm
 * balldyneg       0A4   software.psm
   balldypos       0A6   software.psm
   ballddone       0A7   software.psm
   goto_gameend    0A8   software.psm
   draw_gs         0AB   software.psm
   draw_gs_debug   0B5   software.psm
   draw_attrone    0B8   software.psm
   draw_attrtwo    0F5   software.psm
   draw_playing    111   software.psm
   draw_gameend    138   software.psm
   moveto          172   software.psm
   drawto          175   software.psm
 * isr_vector      7FF   software.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            156
 STAR              -

 AND               -
 OR                -
 XOR               1

 ADD              22
 ADDCY             1
 SUB               6
 SUBCY             1

 TEST              7
 TESTCY            -
 COMPARE          23
 COMPARECY         1

 SL0               -
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               -
 SR1               -
 SRX               5
 SRA               -
 RR                -

 REGBANK           -

 INPUT            10
 OUTPUT           18
 OUTPUTK           -

 STORE             1
 FETCH             1

 DISABLE           -
 ENABLE            1
 RETURNI           1

 JUMP             30
 JUMP@             -
 CALL             70
 CALL@             -
 RETURN           29
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
