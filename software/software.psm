;;============================================================================
;; File: software.psm
;; This is the PicoBlaze example game program for EE178 Lab #8.
;; No guarantee this is bug-free but it is a playable example.
;;============================================================================

;;============================================================================
;; Editor: Thi Le
;; Current Version: 1.2
;; Change Log: 1.0 - initial file provided
;;			   1.1 - replaced padl with tank and cleaned up code
;;			   1.2 - added in bullet and bullet shooting
;;============================================================================

;;============================================================================
;; Ports and related constants.
;;============================================================================

CONSTANT stax            , 00 ; port for 8-bit start-x
CONSTANT stay            , 01 ; port for 8-bit start-y
CONSTANT endx            , 02 ; port for 8-bit end-x
CONSTANT endy            , 03 ; port for 8-bit end-y
CONSTANT busy            , 04 ; port for 8-bit busy
CONSTANT beam            , 05 ; port for 8-bit beam
CONSTANT mode            , 06 ; port for 8-bit mode
CONSTANT prng            , 07 ; port for 8-bit prng
CONSTANT leds_lo         , 08 ; port for 8-bit led data out
CONSTANT leds_hi         , 09 ; port for 8-bit led data out
CONSTANT qssd_lo         , 0a ; port for 8-bit qssd data out
CONSTANT qssd_hi         , 0b ; port for 8-bit qssd data out
CONSTANT qssd_dp         , 0c ; port for 8-bit qssd data out
CONSTANT switches_lo     , 0d ; port for 8-bit switch input
CONSTANT switches_hi     , 0e ; port for 8-bit switch input
CONSTANT buttons         , 0f ; port for 8-bit button input

CONSTANT busy_go         , 01 ; go command and busy status

CONSTANT beam_hi         , 0f ; beam high intensity
CONSTANT beam_md         , 07 ; beam med intensity
CONSTANT beam_lo         , 03 ; beam low intensity

CONSTANT mode_hld        , 00 ; mode hold framebuffer
CONSTANT mode_clr        , 01 ; mode clear framebuffer
CONSTANT mode_lin        , 02 ; mode linear decay
CONSTANT mode_exp        , 03 ; mode exponential decay

CONSTANT buttons_ct      , 10 ; center
CONSTANT buttons_up      , 08 ; up
CONSTANT buttons_dn      , 04 ; down
CONSTANT buttons_lf      , 02 ; left
CONSTANT buttons_rt      , 01 ; right

;;============================================================================
;; Game state declarations.
;;============================================================================

NAMEREG s0, gs_major
CONSTANT gs_major_attrone, 00 ; state assignment
CONSTANT gs_major_attrtwo, 01 ; state assignment
CONSTANT gs_major_playing, 02 ; state assignment
CONSTANT gs_major_gameend, 03 ; state assignment

NAMEREG s1, gs_minor
CONSTANT gs_minor_begins , 00 ; counter initialize
CONSTANT gs_minor_twosec , 78 ; frame count about 2.0 secs
CONSTANT gs_minor_onesec , 3c ; frame count about 1.0 secs
CONSTANT gs_minor_getrdy , 1e ; frame count about 0.5 secs

NAMEREG s2, gs_bulletx
NAMEREG s3, gs_bullety
NAMEREG s5, gs_bulletdy
CONSTANT gs_bullet_xdim  , 00 ; it's this plus 1
CONSTANT gs_bullet_ydim  , 05 ; it's this plus 1
CONSTANT gs_bullet_speed , 06 ; pixels per frame

NAMEREG s6, gs_tankx
CONSTANT gs_tanky        , f4 ; tank y location
CONSTANT gs_tank_xdim    , 10 ; it's this plus 1
CONSTANT gs_tank_ydim    , 08 ; it's this plus 1
CONSTANT gs_tank_speed   , 02 ; pixels per frame

;;============================================================================
;; Global variables.
;;============================================================================

NAMEREG s4, resvd0            ; reserved
NAMEREG s7, resvd1            ; reserved
NAMEREG s8, resvd2            ; reserved

NAMEREG s9, xpos              ; for drawing routines
NAMEREG sA, ypos              ; for drawing routines
NAMEREG sB, bullet_en		  ; for bullet enable
NAMEREG sC, swhsamp           ; switch hi sample
NAMEREG sD, btnsamp           ; button sample
NAMEREG sE, loopvar           ; for loops
NAMEREG sF, scratch           ; for scratch

;;============================================================================
;; Other stuff.
;;============================================================================

CONSTANT minusone        , ff ; minusone
CONSTANT minusmax        , 80 ; minus 128
CONSTANT plusmax         , 7f ; plus 127
CONSTANT zero            , 00 ; zero
CONSTANT one             , 01 ; one

;;============================================================================
;; Boot.
;; This performs one-time initialization of the hardware and the game state.
;;============================================================================

         boot: CALL hw_init                        ; initial hardware setup
               CALL gs_init                        ; set initial game state
               ENABLE INTERRUPT                    ; enable vblnk interrupt

;;============================================================================
;; Main.
;; This is an empty loop, does nothing, waiting for interrupts to occur.
;;============================================================================

         main: JUMP main                           ; empty loop, does nothing

;;============================================================================
;; Interrupt.
;; This is the main game logic.  At each interrupt, the procedure is to read
;; the user input, calculate the next game state, and then draw the game
;; state on the display.
;;============================================================================

          isr: CALL user_input                     ; get the user input
               CALL calc_next_gs                   ; calculate next state
               CALL draw_gs                        ; draw the state
               RETURNI ENABLE                      ; return with enable

;;============================================================================
;; Subroutine: hw_init
;; This puts the hardware into a known, initial state.  This includes a wait
;; to make sure the line drawing harware is idle (a wait loop which is also
;; called from other routines, as a subroutine).
;;============================================================================

      hw_init: LOAD scratch, zero                  ; going to use lot of zero
               OUTPUT scratch, leds_lo             ; turn off lo leds
               OUTPUT scratch, leds_hi             ; turn off hi leds
               OUTPUT scratch, qssd_lo             ; zeroize qssd lo
               OUTPUT scratch, qssd_hi             ; zeroize qssd hi
               OUTPUT scratch, qssd_dp             ; turn off qssd dots
               LOAD scratch, mode_exp              ; load desired mode
               OUTPUT scratch, mode                ; program the framebuffer
               LOAD scratch, beam_hi               ; load desired beam
               OUTPUT scratch, beam                ; program the framebuffer
 hw_init_wait: INPUT scratch, busy                 ; get framebuffer busy
               COMPARE scratch, busy_go            ; check framebuffer busy
               JUMP Z, hw_init_wait                ; back to wait if busy
               RETURN                              ; return

;;============================================================================
;; Subroutine: gs_init
;; This puts the game into a known, initial state.  I've assigned all of the
;; game state to a known value -- although some of these assignments do not
;; really matter based on design of the game state machine.
;;============================================================================

      gs_init: LOAD gs_major, gs_major_attrone     ; start in attract mdoe
               LOAD gs_minor, gs_minor_begins      ; start with counter zero
               LOAD gs_bulletx, zero               ; doesn't really matter
               LOAD gs_bullety, zero               ; doesn't really matter
               LOAD gs_tankx, zero                 ; doesn't really matter
               LOAD gs_bulletdy, zero              ; doesn't really matter
			   LOAD bullet_en, zero
               RETURN                              ; return

;;============================================================================
;; Subroutine: user_input
;; This samples the user inputs required for this game (which happens to be
;; only the buttons, but this could is extended to the switches as well).
;; This subroutine calls an example of how to use the RAM scratchpad, by
;; implementing access of a 256x8 array using switches, button, and qssd.
;; The call to the ram_example routine (and ram_example routine itself)
;; can be entirely removed as it is not needed in this game.
;;============================================================================

   user_input: INPUT btnsamp, buttons              ; sample button hardware
              ;INPUT swlsamp, switches_lo          ; sample switch lo hardware
              ;INPUT swhsamp, switches_hi          ; sample switch hi hardware
              ;CALL ram_example                    ; do the ram example
               RETURN                              ; return

  ; ram_example: OUTPUT swhsamp, qssd_hi             ; display ram address
               ; FETCH scratch, (swhsamp)            ; read the ram at addr
               ; OUTPUT scratch, qssd_lo             ; display data from ram
               ; TEST btnsamp, buttons_dn            ; does user want to write
               ; RETURN Z                            ; if not then return
               ; STORE swlsamp, (swhsamp)            ; write the ram at addr
               ; RETURN                              ; return

;;============================================================================
;; Subroutine: calc_next_gs
;; This logic calculates the next state of the game, given the sampled user
;; inputs and the current state of the game.
;;============================================================================

   calc_next_gs: COMPARE gs_major, gs_major_attrone  ; are we in attrone?
                 JUMP Z, calc_attrone                 ; do ns calc for attrone
                 COMPARE gs_major, gs_major_attrtwo  ; are we in attrtwo?
                 JUMP Z, calc_attrtwo                 ; do ns calc for attrtwo
                 COMPARE gs_major, gs_major_playing  ; are we in playing?
                 JUMP Z, calc_playing                 ; do ns calc for playing
                 COMPARE gs_major, gs_major_gameend  ; are we in gameend?
                 JUMP Z, calc_gameend                 ; do ns calc for gameend
                 RETURN

   calc_attrone: TEST btnsamp, buttons_ct             ; starts game if center button is pressed
                 JUMP NZ, goto_playing                ; othersize, swap between bong and ec
                 COMPARE gs_minor, gs_minor_twosec   ; attrone is bong, attrtwo is ec
                 JUMP Z, goto_attrtwo
                 ADD gs_minor, one
                 RETURN

   calc_attrtwo: TEST btnsamp, buttons_ct
                 JUMP NZ, goto_playing
                 COMPARE gs_minor, gs_minor_onesec
                 JUMP Z, goto_attrone
                 ADD gs_minor, one
                 RETURN
				 
   goto_playing: LOAD gs_tankx, gs_tank_xdim			; start tank at the bottom horizontal center of screen
                 SRX gs_tankx
                 XOR gs_tankx, minusone
                 ADD gs_tankx, one
                 ADD gs_tankx, minusmax
				 LOAD scratch, gs_tankx				; start bullet at the upper center of the tank
			     ADD scratch, 08
                 LOAD gs_bulletx, scratch
			     LOAD scratch, gs_tanky
			     SUB scratch, 03
			     LOAD gs_bullety, scratch
			     LOAD gs_major, gs_major_playing
                 LOAD gs_minor, gs_minor_begins
			     RETURN

   calc_playing: CALL upd_tank							; go to update tank position
				 TEST btnsamp, buttons_up				; check if the top button was pushed
				 CALL NZ, load_bullet_en				; if it was, enable bullet enable
				 COMPARE bullet_en, zero				; check if bullet enable is enabled
				 CALL NZ, upd_bullet					; if it is, update shot bullet position
				 RETURN
				 
       upd_tank: LOAD scratch, zero					; update tank position
                 TEST btnsamp, buttons_lf
                 SUBCY scratch, zero
                 TEST btnsamp, buttons_rt
                 ADDCY scratch, zero
                 COMPARE scratch, minusone
                 CALL Z, upd_tank_lt
                 COMPARE scratch, one
                 CALL Z, upd_tank_rt
				 COMPARE bullet_en, zero				; if bullet enable is 0, update unshot bullet x position
				 RETURN NZ							; if bullet enable is 1, do not update bullet x position
				 LOAD scratch, gs_tankx				; update unshot bullet x position
				 ADD scratch, 08
                 LOAD gs_bulletx, scratch
                 RETURN
    upd_tank_lt: SUB gs_tankx, gs_tank_speed
                 RETURN NC
                 LOAD gs_tankx, zero
                 RETURN
    upd_tank_rt: ADD gs_tankx, gs_tank_speed
                 LOAD scratch, gs_tankx
                 ADD scratch, gs_tank_xdim
                 RETURN NC
                 LOAD gs_tankx, minusone
                 SUB gs_tankx, gs_tank_xdim
                 RETURN

 load_bullet_en: LOAD bullet_en, one					; enable bullet enable
				 RETURN
				 
	 upd_bullet: LOAD loopvar, gs_bullet_speed			; loop for bullety moving up
upd_bullet_loop: SUB loopvar, one
				 RETURN C								; needed for some reason I do not know
				 SUB gs_bullety, one
                 JUMP Z, reset_bullet
				 JUMP upd_bullet_loop
   reset_bullet: LOAD scratch, gs_tankx				; when bullet hits the top, reload the bullet position
				 ADD scratch, 08
                 LOAD gs_bulletx, scratch
				 LOAD scratch, gs_tanky
				 SUB scratch, 03
				 LOAD gs_bullety, scratch
				 LOAD bullet_en, zero
				 RETURN

   calc_gameend: COMPARE gs_minor, gs_minor_onesec
                 JUMP Z, goto_attrone
                 ADD gs_minor, one
                 RETURN

   goto_attrone: LOAD gs_major, gs_major_attrone
			     LOAD gs_minor, gs_minor_begins
                 RETURN

   goto_attrtwo: LOAD gs_major, gs_major_attrtwo
                 LOAD gs_minor, gs_minor_begins
                 RETURN

   goto_gameend: LOAD gs_major, gs_major_gameend
                 LOAD gs_minor, gs_minor_begins
                 RETURN

;;============================================================================
;; Subroutine: draw_gs
;; This uses the current game state as input, and draws it on the display.
;; This subroutine calls an example of how to output debug or diagnostic info
;; using the leds.  The call to the draw_gs_debug routine (and draw_gs_debug
;; routine itself) can be entirely remove as it is required to play the game.
;;============================================================================

      draw_gs: CALL draw_gs_debug                  ; for debug info display
               COMPARE gs_major, gs_major_attrone  ; are we in attrone?
               JUMP Z, draw_attrone                ; do drawing for attrone
               COMPARE gs_major, gs_major_attrtwo  ; are we in attrtwo?
               JUMP Z, draw_attrtwo                ; do drawing for attrtwo
               COMPARE gs_major, gs_major_playing  ; are we in playing?
               JUMP Z, draw_playing                ; do drawing for playing
               COMPARE gs_major, gs_major_gameend  ; are we in gameend?
               JUMP Z, draw_gameend                ; do drawing for gameend
               RETURN                              ; return

draw_gs_debug: OUTPUT gs_major, leds_hi            ; debug display on leds
               OUTPUT gs_minor, leds_lo            ; debug display on leds
               RETURN                              ; return

 draw_attrone: LOAD xpos, 28 ; draw letter b
               LOAD ypos, 50
               CALL moveto
               LOAD xpos, 28
               LOAD ypos, 90
               CALL drawto
               LOAD xpos, 48
               LOAD ypos, 90
               CALL drawto
               LOAD xpos, 48
               LOAD ypos, 70
               CALL drawto
               LOAD xpos, 28
               LOAD ypos, 70
               CALL drawto
               LOAD xpos, 58 ; draw letter o
               LOAD ypos, 70
               CALL moveto
               LOAD xpos, 58
               LOAD ypos, 90
               CALL drawto
               LOAD xpos, 78
               LOAD ypos, 90
               CALL drawto
               LOAD xpos, 78
               LOAD ypos, 70
               CALL drawto
               LOAD xpos, 58
               LOAD ypos, 70
               CALL drawto
               LOAD xpos, 88 ; draw letter n
               LOAD ypos, 90
               CALL moveto
               LOAD xpos, 88
               LOAD ypos, 70
               CALL drawto
               LOAD xpos, a8
               LOAD ypos, 70
               CALL drawto
               LOAD xpos, a8
               LOAD ypos, 90
               CALL drawto
               LOAD xpos, b8 ; draw letter g
               LOAD ypos, b0
               CALL moveto
               LOAD xpos, d8
               LOAD ypos, b0
               CALL drawto
               LOAD xpos, d8
               LOAD ypos, 70
               CALL drawto
               LOAD xpos, b8
               LOAD ypos, 70
               CALL drawto
               LOAD xpos, b8
               LOAD ypos, 90
               CALL drawto
               LOAD xpos, d8
               LOAD ypos, 90
               CALL drawto
               RETURN

 draw_attrtwo: LOAD xpos, 78 ; draw letter e
               LOAD ypos, 90
               CALL moveto
               LOAD xpos, 58
               LOAD ypos, 90
               CALL drawto
               LOAD xpos, 58
               LOAD ypos, 70
               CALL drawto
               LOAD xpos, 78
               LOAD ypos, 70
               CALL drawto
               LOAD xpos, 58
               LOAD ypos, 90
               CALL drawto
               LOAD xpos, a8 ; draw letter c
               LOAD ypos, 70
               CALL moveto
               LOAD xpos, 88
               LOAD ypos, 70
               CALL drawto
               LOAD xpos, 88
               LOAD ypos, 90
               CALL drawto
               LOAD xpos, a8
               LOAD ypos, 90
               CALL drawto
               RETURN

 draw_playing: LOAD xpos, gs_bulletx ; draw bullet
               LOAD ypos, gs_bullety
               CALL moveto
               LOAD xpos, gs_bulletx
               LOAD ypos, gs_bullety
               ADD ypos, gs_bullet_ydim
               CALL drawto
               LOAD xpos, gs_tankx ; draw tank
               LOAD ypos, gs_tanky
               CALL moveto
               LOAD xpos, gs_tankx
               LOAD ypos, gs_tanky
               ADD ypos, gs_tank_ydim
               CALL drawto
               LOAD xpos, gs_tankx
               LOAD ypos, gs_tanky
               ADD xpos, gs_tank_xdim
               ADD ypos, gs_tank_ydim
               CALL drawto
               LOAD xpos, gs_tankx
               LOAD ypos, gs_tanky
               ADD xpos, gs_tank_xdim
               CALL drawto
               LOAD xpos, gs_tankx
               LOAD ypos, gs_tanky
               CALL drawto			   
               RETURN

 draw_gameend: LOAD xpos, 48 ; draw letter d
               LOAD ypos, 50
               CALL moveto
               LOAD xpos, 48
               LOAD ypos, 90
               CALL drawto
               LOAD xpos, 28
               LOAD ypos, 90
               CALL drawto
               LOAD xpos, 28
               LOAD ypos, 70
               CALL drawto
               LOAD xpos, 48
               LOAD ypos, 70
               CALL drawto
               LOAD xpos, 58 ; draw letter o
               LOAD ypos, 70
               CALL moveto
               LOAD xpos, 58
               LOAD ypos, 90
               CALL drawto
               LOAD xpos, 78
               LOAD ypos, 90
               CALL drawto
               LOAD xpos, 78
               LOAD ypos, 70
               CALL drawto
               LOAD xpos, 58
               LOAD ypos, 70
               CALL drawto
               LOAD xpos, 88 ; draw letter n
               LOAD ypos, 90
               CALL moveto
               LOAD xpos, 88
               LOAD ypos, 70
               CALL drawto
               LOAD xpos, a8
               LOAD ypos, 70
               CALL drawto
               LOAD xpos, a8
               LOAD ypos, 90
               CALL drawto
               LOAD xpos, d8 ; draw letter e
               LOAD ypos, 90
               CALL moveto
               LOAD xpos, b8
               LOAD ypos, 90
               CALL drawto
               LOAD xpos, b8
               LOAD ypos, 70
               CALL drawto
               LOAD xpos, d8
               LOAD ypos, 70
               CALL drawto
               LOAD xpos, b8
               LOAD ypos, 90
               CALL drawto
               RETURN

;;============================================================================
;; Subroutine: moveto and drawto
;; The moveto routine uses the global variables xpos and ypos, and the drawto
;; routine uses these global variables as well as the endpoint coordinates in
;; the display controller.  Moveto simply copies xpos and ypos into endpoint
;; coordinates in the display controller, it does not draw anything.  The
;; drawto routine copies endpoint coordinates to startpoint coordinates (does
;; not matter if the endpoint was from an actual draw, or simply an update
;; by moveto) and then copies xpos and ypos into endpoint coordinates, then
;; starts a linedraw.
;;============================================================================

       moveto: OUTPUT xpos, endx                   ; copy global to hardware
               OUTPUT ypos, endy                   ; copy global to hardware
               RETURN                              ; return

       drawto: INPUT scratch, endx                 ; read hardware
               OUTPUT scratch, stax                ; write hardware
               OUTPUT xpos, endx                   ; copy global to hardware
               INPUT scratch, endy                 ; read hardware
               OUTPUT scratch, stay                ; write hardware
               OUTPUT ypos, endy                   ; copy global to hardware
               LOAD scratch, busy_go               ; prepare the command
               OUTPUT scratch, busy                ; send the command
               CALL hw_init_wait                   ; wait line draw done
               RETURN                              ; return

;;============================================================================
;; Interrupt - Vector.
;;============================================================================

               ADDRESS 7FF                         ; must be located here
   isr_vector: JUMP isr                            ; always jump to isr

;;============================================================================
;;
;;============================================================================
