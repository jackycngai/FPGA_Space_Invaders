KCPSM6 Assembler log file for program 'C:\Users\daime\OneDrive\Documents\School\Semester 9\EE 178\SpaceInvaders\FPGA_Space_Invaders\software\SOFTWARECOPY.PSM'.
Generated by KCPSM6 version v2.51
Ken Chapman - Xilinx Ltd - 29th May 2013

Assembly datestamp: 06 Dec 2016
Assembly timestamp: 18:51:54

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 7FF hex
Nominal program memory size: 2K (2048)   address(10:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 363
Memory locations available: 3733


Assembly listing

 Addr Code                  Instruction

 000                        ;;============================================================================
 000                        ;; File: software.psm
 000                        ;; This is the PicoBlaze example game program for EE178 Lab #8.
 000                        ;; No guarantee this is bug-free but it is a playable example.
 000                        ;;============================================================================
 000                        ;;============================================================================
 000                        ;; Ports and related constants.
 000                        ;;============================================================================
 000                        CONSTANT stax, 00                          ; port for 8-bit start-x
 000                        CONSTANT stay, 01                          ; port for 8-bit start-y
 000                        CONSTANT endx, 02                          ; port for 8-bit end-x
 000                        CONSTANT endy, 03                          ; port for 8-bit end-y
 000                        CONSTANT busy, 04                          ; port for 8-bit busy
 000                        CONSTANT beam, 05                          ; port for 8-bit beam
 000                        CONSTANT mode, 06                          ; port for 8-bit mode
 000                        CONSTANT prng, 07                          ; port for 8-bit prng
 000                        CONSTANT leds_lo, 08                       ; port for 8-bit led data out
 000                        CONSTANT leds_hi, 09                       ; port for 8-bit led data out
 000                        CONSTANT qssd_lo, 0A                       ; port for 8-bit qssd data out
 000                        CONSTANT qssd_hi, 0B                       ; port for 8-bit qssd data out
 000                        CONSTANT qssd_dp, 0C                       ; port for 8-bit qssd data out
 000                        CONSTANT switches_lo, 0D                   ; port for 8-bit switch input
 000                        CONSTANT switches_hi, 0E                   ; port for 8-bit switch input
 000                        CONSTANT buttons, 0F                       ; port for 8-bit button input
 000                        CONSTANT busy_go, 01                       ; go command and busy status
 000                        CONSTANT beam_hi, 0F                       ; beam high intensity
 000                        CONSTANT beam_md, 07                       ; beam med intensity
 000                        CONSTANT beam_lo, 03                       ; beam low intensity
 000                        CONSTANT mode_hld, 00                      ; mode hold framebuffer
 000                        CONSTANT mode_clr, 01                      ; mode clear framebuffer
 000                        CONSTANT mode_lin, 02                      ; mode linear decay
 000                        CONSTANT mode_exp, 03                      ; mode exponential decay
 000                        CONSTANT buttons_ct, 10                    ; center
 000                        CONSTANT buttons_up, 08                    ; up
 000                        CONSTANT buttons_dn, 04                    ; down
 000                        CONSTANT buttons_lf, 02                    ; left
 000                        CONSTANT buttons_rt, 01                    ; right
 000                        ;;============================================================================
 000                        ;; Game state declarations.
 000                        ;;============================================================================
 000                        NAMEREG s0, gs_major
 000                        CONSTANT gs_major_attrone, 00              ; state assignment
 000                        CONSTANT gs_major_attrtwo, 01              ; state assignment
 000                        CONSTANT gs_major_playing, 02              ; state assignment
 000                        CONSTANT gs_major_gameend, 03              ; state assignment
 000                        NAMEREG s1, gs_minor
 000                        CONSTANT gs_minor_begins, 00               ; counter initialize
 000                        CONSTANT gs_minor_twosec, 78               ; frame count about 2.0 secs
 000                        CONSTANT gs_minor_onesec, 3C               ; frame count about 1.0 secs
 000                        CONSTANT gs_minor_getrdy, 1E               ; frame count about 0.5 secs
 000                        NAMEREG s2, gs_ballx
 000                        NAMEREG s3, gs_bally
 000                        NAMEREG s4, gs_balldx
 000                        NAMEREG s5, gs_balldy
 000                        CONSTANT gs_ball_xdim, 08                  ; it's this plus 1
 000                        CONSTANT gs_ball_ydim, 08                  ; it's this plus 1
 000                        CONSTANT gs_ball_speed, 03                 ; pixels per frame
 000                        NAMEREG s6, gs_padlx
 000                        CONSTANT gs_padly, D0                      ; paddle y location
 000                        CONSTANT gs_padl_xdim, 20                  ; it's this plus 1
 000                        CONSTANT gs_padl_ydim, 08                  ; it's this plus 1
 000                        CONSTANT gs_padl_speed, 04                 ; pixels per frame
 000                        ;;============================================================================
 000                        ;; Global variables.
 000                        ;;============================================================================
 000                        NAMEREG s7, resvd1                         ; reserved
 000                        NAMEREG s8, resvd2                         ; reserved
 000                        NAMEREG s9, xpos                           ; for drawing routines
 000                        NAMEREG sA, ypos                           ; for drawing routines
 000                        NAMEREG sB, swlsamp                        ; switch lo sample
 000                        NAMEREG sC, swhsamp                        ; switch hi sample
 000                        NAMEREG sD, btnsamp                        ; button sample
 000                        NAMEREG sE, loopvar                        ; for loops
 000                        NAMEREG sF, scratch                        ; for scratch
 000                        ;;============================================================================
 000                        ;; Other stuff.
 000                        ;;============================================================================
 000                        CONSTANT minusone, FF                      ; minusone
 000                        CONSTANT minusmax, 80                      ; minus 128
 000                        CONSTANT plusmax, 7F                       ; plus 127
 000                        CONSTANT zero, 00                          ; zero
 000                        CONSTANT one, 01                           ; one
 000                        ;;============================================================================
 000                        ;; Boot.
 000                        ;; This performs one-time initialization of the hardware and the game state.
 000                        ;;============================================================================
 000  20008           boot: CALL 008[hw_init]                          ; initial hardware setup
 001  20016                 CALL 016[gs_init]                          ; set initial game state
 002  28001                 ENABLE INTERRUPT                           ; enable vblnk interrupt
 003                        ;;============================================================================
 003                        ;; Main.
 003                        ;; This is an empty loop, does nothing, waiting for interrupts to occur.
 003                        ;;============================================================================
 003  22003           main: JUMP 003[main]                             ; empty loop, does nothing
 004                        ;;============================================================================
 004                        ;; Interrupt.
 004                        ;; This is the main game logic.  At each interrupt, the procedure is to read
 004                        ;; the user input, calculate the next game state, and then draw the game
 004                        ;; state on the display.
 004                        ;;============================================================================
 004  2001E            isr: CALL 01E[user_input]                       ; get the user input
 005  2002A                 CALL 02A[calc_next_gs]                     ; calculate next state
 006  200AB                 CALL 0AB[draw_gs]                          ; draw the state
 007  29001                 RETURNI ENABLE                             ; return with enable
 008                        ;;============================================================================
 008                        ;; Subroutine: hw_init
 008                        ;; This puts the hardware into a known, initial state.  This includes a wait
 008                        ;; to make sure the line drawing harware is idle (a wait loop which is also
 008                        ;; called from other routines, as a subroutine).
 008                        ;;============================================================================
 008  01F00        hw_init: LOAD sF[scratch], 00[zero]                 ; going to use lot of zero
 009  2DF08                 OUTPUT sF[scratch], 08[leds_lo]            ; turn off lo leds
 00A  2DF09                 OUTPUT sF[scratch], 09[leds_hi]            ; turn off hi leds
 00B  2DF0A                 OUTPUT sF[scratch], 0A[qssd_lo]            ; zeroize qssd lo
 00C  2DF0B                 OUTPUT sF[scratch], 0B[qssd_hi]            ; zeroize qssd hi
 00D  2DF0C                 OUTPUT sF[scratch], 0C[qssd_dp]            ; turn off qssd dots
 00E  01F03                 LOAD sF[scratch], 03[mode_exp]             ; load desired mode
 00F  2DF06                 OUTPUT sF[scratch], 06[mode]               ; program the framebuffer
 010  01F0F                 LOAD sF[scratch], 0F[beam_hi]              ; load desired beam
 011  2DF05                 OUTPUT sF[scratch], 05[beam]               ; program the framebuffer
 012  09F04   hw_init_wait: INPUT sF[scratch], 04[busy]                ; get framebuffer busy
 013  1DF01                 COMPARE sF[scratch], 01[busy_go]           ; check framebuffer busy
 014  32012                 JUMP Z, 012[hw_init_wait]                  ; back to wait if busy
 015  25000                 RETURN                                     ; return
 016                        ;;============================================================================
 016                        ;; Subroutine: gs_init
 016                        ;; This puts the game into a known, initial state.  I've assigned all of the
 016                        ;; game state to a known value -- although some of these assignments do not
 016                        ;; really matter based on design of the game state machine.
 016                        ;;============================================================================
 016  01000        gs_init: LOAD s0[gs_major], 00[gs_major_attrone]    ; start in attract mdoe
 017  01100                 LOAD s1[gs_minor], 00[gs_minor_begins]     ; start with counter zero
 018  01200                 LOAD s2[gs_ballx], 00[zero]                ; doesn't really matter
 019  01300                 LOAD s3[gs_bally], 00[zero]                ; doesn't really matter
 01A  01600                 LOAD s6[gs_padlx], 00[zero]                ; doesn't really matter
 01B  01400                 LOAD s4[gs_balldx], 00[zero]               ; doesn't really matter
 01C  01500                 LOAD s5[gs_balldy], 00[zero]               ; doesn't really matter
 01D  25000                 RETURN                                     ; return
 01E                        ;;============================================================================
 01E                        ;; Subroutine: user_input Daimen's Part
 01E                        ;; This samples the user inputs required for this game (which happens to be
 01E                        ;; only the buttons, but this could is extended to the switches as well).
 01E                        ;; This subroutine calls an example of how to use the RAM scratchpad, by
 01E                        ;; implementing access of a 256x8 array using switches, button, and qssd.
 01E                        ;; The call to the ram_example routine (and ram_example routine itself)
 01E                        ;; can be entirely removed as it is not needed in this game.
 01E                        ;;============================================================================
 01E  09D0F     user_input: INPUT sD[btnsamp], 0F[buttons]             ; sample button hardware
 01F  09B0D                 INPUT sB[swlsamp], 0D[switches_lo]         ; sample switch lo hardware
 020  09C0E                 INPUT sC[swhsamp], 0E[switches_hi]         ; sample switch hi hardware
 021  20023                 CALL 023[ram_example]                      ; do the ram example
 022  25000                 RETURN                                     ; return
 023  2DC0B    ram_example: OUTPUT sC[swhsamp], 0B[qssd_hi]            ; display ram address
 024  0AFC0                 FETCH sF[scratch], (sC[swhsamp])           ; read the ram at addr
 025  2DF0A                 OUTPUT sF[scratch], 0A[qssd_lo]            ; display data from ram
 026  0DD04                 TEST sD[btnsamp], 04[buttons_dn]           ; does user want to write
 027  31000                 RETURN Z                                   ; if not then return
 028  2EBC0                 STORE sB[swlsamp], (sC[swhsamp])           ; write the ram at addr
 029  25000                 RETURN                                     ; return
 02A                        ;;============================================================================
 02A                        ;; Subroutine: calc_next_gs
 02A                        ;; This logic calculates the next state of the game, given the sampled user
 02A                        ;; inputs and the current state of the game.
 02A                        ;;============================================================================
 02A  1D000   calc_next_gs: COMPARE s0[gs_major], 00[gs_major_attrone] ; are we in attrone?
 02B  32033                 JUMP Z, 033[calc_attrone]                  ; do ns calc for attrone
 02C  1D001                 COMPARE s0[gs_major], 01[gs_major_attrtwo] ; are we in attrtwo?
 02D  32039                 JUMP Z, 039[calc_attrtwo]                  ; do ns calc for attrtwo
 02E  1D002                 COMPARE s0[gs_major], 02[gs_major_playing] ; are we in playing?
 02F  3203F                 JUMP Z, 03F[calc_playing]                  ; do ns calc for playing
 030  1D003                 COMPARE s0[gs_major], 03[gs_major_gameend] ; are we in gameend?
 031  32082                 JUMP Z, 082[calc_gameend]                  ; do ns calc for gameend
 032  25000                 RETURN                                     ; return
 033  0DD10   calc_attrone: TEST sD[btnsamp], 10[buttons_ct]
 034  3608C                 JUMP NZ, 08C[goto_playing]
 035  1D178                 COMPARE s1[gs_minor], 78[gs_minor_twosec]
 036  32089                 JUMP Z, 089[goto_attrtwo]
 037  11101                 ADD s1[gs_minor], 01[one]
 038  25000                 RETURN 
 039  0DD10   calc_attrtwo: TEST sD[btnsamp], 10[buttons_ct]
 03A  3608C                 JUMP NZ, 08C[goto_playing]
 03B  1D13C                 COMPARE s1[gs_minor], 3C[gs_minor_onesec]
 03C  32086                 JUMP Z, 086[goto_attrone]
 03D  11101                 ADD s1[gs_minor], 01[one]
 03E  25000                 RETURN 
 03F  20049   calc_playing: CALL 049[upd_padl]
 040  1D11E                 COMPARE s1[gs_minor], 1E[gs_minor_getrdy]
 041  3E044                 JUMP NC, 044[goplay]
 042  11101         getrdy: ADD s1[gs_minor], 01[one]
 043  25000                 RETURN 
 044  2005E         goplay: CALL 05E[upd_ball]
 045  1D500                 COMPARE s5[gs_balldy], 00[zero]
 046  1F400                 COMPARECY s4[gs_balldx], 00[zero]
 047  320A8                 JUMP Z, 0A8[goto_gameend]
 048  25000                 RETURN 
 049  01F00       upd_padl: LOAD sF[scratch], 00[zero]
 04A  0DD02                 TEST sD[btnsamp], 02[buttons_lf]
 04B  1BF00                 SUBCY sF[scratch], 00[zero]
 04C  0DD01                 TEST sD[btnsamp], 01[buttons_rt]
 04D  13F00                 ADDCY sF[scratch], 00[zero]
 04E  1DFFF                 COMPARE sF[scratch], FF[minusone]
 04F  30053                 CALL Z, 053[upd_padl_lt]
 050  1DF01                 COMPARE sF[scratch], 01[one]
 051  30057                 CALL Z, 057[upd_padl_rt]
 052  25000                 RETURN 
 053  19604    upd_padl_lt: SUB s6[gs_padlx], 04[gs_padl_speed]
 054  3D000                 RETURN NC
 055  01600                 LOAD s6[gs_padlx], 00[zero]
 056  25000                 RETURN 
 057  11604    upd_padl_rt: ADD s6[gs_padlx], 04[gs_padl_speed]
 058  00F60                 LOAD sF[scratch], s6[gs_padlx]
 059  11F20                 ADD sF[scratch], 20[gs_padl_xdim]
 05A  3D000                 RETURN NC
 05B  016FF                 LOAD s6[gs_padlx], FF[minusone]
 05C  19620                 SUB s6[gs_padlx], 20[gs_padl_xdim]
 05D  25000                 RETURN 
 05E  01E03       upd_ball: LOAD sE[loopvar], 03[gs_ball_speed]
 05F  19E01  upd_ball_loop: SUB sE[loopvar], 01[one]
 060  39000                 RETURN C
 061  10240  upd_ball_step: ADD s2[gs_ballx], s4[gs_balldx]
 062  10350                 ADD s3[gs_bally], s5[gs_balldy]
 063  01FD0  upd_ball_padl: LOAD sF[scratch], D0[gs_padly]
 064  19F08                 SUB sF[scratch], 08[gs_ball_ydim]
 065  1C3F0                 COMPARE s3[gs_bally], sF[scratch]
 066  36070                 JUMP NZ, 070[upd_ball_lw]
 067  00F20                 LOAD sF[scratch], s2[gs_ballx]
 068  11F08                 ADD sF[scratch], 08[gs_ball_xdim]
 069  1CF60                 COMPARE sF[scratch], s6[gs_padlx]
 06A  3A070                 JUMP C, 070[upd_ball_lw]
 06B  00F60                 LOAD sF[scratch], s6[gs_padlx]
 06C  11F20                 ADD sF[scratch], 20[gs_padl_xdim]
 06D  1CF20                 COMPARE sF[scratch], s2[gs_ballx]
 06E  3A070                 JUMP C, 070[upd_ball_lw]
 06F  015FF                 LOAD s5[gs_balldy], FF[minusone]
 070  1D200    upd_ball_lw: COMPARE s2[gs_ballx], 00[zero]
 071  36073                 JUMP NZ, 073[upd_ball_tw]
 072  01401                 LOAD s4[gs_balldx], 01[one]
 073  1D300    upd_ball_tw: COMPARE s3[gs_bally], 00[zero]
 074  36076                 JUMP NZ, 076[upd_ball_rw]
 075  01501                 LOAD s5[gs_balldy], 01[one]
 076  01FFF    upd_ball_rw: LOAD sF[scratch], FF[minusone]
 077  19F08                 SUB sF[scratch], 08[gs_ball_xdim]
 078  1C2F0                 COMPARE s2[gs_ballx], sF[scratch]
 079  3607B                 JUMP NZ, 07B[upd_ball_bw]
 07A  014FF                 LOAD s4[gs_balldx], FF[minusone]
 07B  01FFF    upd_ball_bw: LOAD sF[scratch], FF[minusone]
 07C  19F08                 SUB sF[scratch], 08[gs_ball_ydim]
 07D  1C3F0                 COMPARE s3[gs_bally], sF[scratch]
 07E  36081                 JUMP NZ, 081[upd_ball_done]
 07F  01500                 LOAD s5[gs_balldy], 00[zero]
 080  01400                 LOAD s4[gs_balldx], 00[zero]
 081  2205F  upd_ball_done: JUMP 05F[upd_ball_loop]
 082  1D13C   calc_gameend: COMPARE s1[gs_minor], 3C[gs_minor_onesec]
 083  32086                 JUMP Z, 086[goto_attrone]
 084  11101                 ADD s1[gs_minor], 01[one]
 085  25000                 RETURN 
 086  01000   goto_attrone: LOAD s0[gs_major], 00[gs_major_attrone]
 087  01100                 LOAD s1[gs_minor], 00[gs_minor_begins]
 088  25000                 RETURN 
 089  01001   goto_attrtwo: LOAD s0[gs_major], 01[gs_major_attrtwo]
 08A  01100                 LOAD s1[gs_minor], 00[gs_minor_begins]
 08B  25000                 RETURN 
 08C  01002   goto_playing: LOAD s0[gs_major], 02[gs_major_playing]
 08D  01100                 LOAD s1[gs_minor], 00[gs_minor_begins]
 08E                        ; get a seed for initial ballx
 08E  09207                 INPUT s2[gs_ballx], 07[prng]
 08F                        ; start ball somewhere in the
 08F                        ; horizontal center of screen
 08F  1420A                 SRX s2[gs_ballx]
 090  1420A                 SRX s2[gs_ballx]
 091  1127F                 ADD s2[gs_ballx], 7F[plusmax]
 092                        ; get a seed for initial bally
 092  09307                 INPUT s3[gs_bally], 07[prng]
 093                        ; start ball somewhere in the
 093                        ; vertical center of screen
 093  1430A                 SRX s3[gs_bally]
 094  1430A                 SRX s3[gs_bally]
 095  1137F                 ADD s3[gs_bally], 7F[plusmax]
 096                        ; start paddle at the horizontal
 096                        ; center of the screen
 096  01620                 LOAD s6[gs_padlx], 20[gs_padl_xdim]
 097  1460A                 SRX s6[gs_padlx]
 098  076FF                 XOR s6[gs_padlx], FF[minusone]
 099  11601                 ADD s6[gs_padlx], 01[one]
 09A  11680                 ADD s6[gs_padlx], 80[minusmax]
 09B                        ; initial direction for ballx
 09B                        ; desire to start at +1 or -1
 09B  09407      balldxsta: INPUT s4[gs_balldx], 07[prng]
 09C  0D480                 TEST s4[gs_balldx], 80[minusmax]
 09D  320A0                 JUMP Z, 0A0[balldxpos]
 09E  014FF      balldxneg: LOAD s4[gs_balldx], FF[minusone]
 09F  220A1                 JUMP 0A1[balldysta]
 0A0  01401      balldxpos: LOAD s4[gs_balldx], 01[one]
 0A1                        ; initial direction for bally
 0A1                        ; desire to start at +1 or -1
 0A1  09507      balldysta: INPUT s5[gs_balldy], 07[prng]
 0A2  0D580                 TEST s5[gs_balldy], 80[minusmax]
 0A3  320A6                 JUMP Z, 0A6[balldypos]
 0A4  015FF      balldyneg: LOAD s5[gs_balldy], FF[minusone]
 0A5  220A7                 JUMP 0A7[ballddone]
 0A6  01501      balldypos: LOAD s5[gs_balldy], 01[one]
 0A7  25000      ballddone: RETURN 
 0A8  01003   goto_gameend: LOAD s0[gs_major], 03[gs_major_gameend]
 0A9  01100                 LOAD s1[gs_minor], 00[gs_minor_begins]
 0AA  25000                 RETURN 
 0AB                        ;;============================================================================
 0AB                        ;; Subroutine: draw_gs
 0AB                        ;; This uses the current game state as input, and draws it on the display.
 0AB                        ;; This subroutine calls an example of how to output debug or diagnostic info
 0AB                        ;; using the leds.  The call to the draw_gs_debug routine (and draw_gs_debug
 0AB                        ;; routine itself) can be entirely remove as it is required to play the game.
 0AB                        ;;============================================================================
 0AB  200B5        draw_gs: CALL 0B5[draw_gs_debug]                    ; for debug info display
 0AC  1D000                 COMPARE s0[gs_major], 00[gs_major_attrone] ; are we in attrone?
 0AD  320B8                 JUMP Z, 0B8[draw_attrone]                  ; do drawing for attrone
 0AE  1D001                 COMPARE s0[gs_major], 01[gs_major_attrtwo] ; are we in attrtwo?
 0AF  320E0                 JUMP Z, 0E0[draw_attrtwo]                  ; do drawing for attrtwo
 0B0  1D002                 COMPARE s0[gs_major], 02[gs_major_playing] ; are we in playing?
 0B1  320FC                 JUMP Z, 0FC[draw_playing]                  ; do drawing for playing
 0B2  1D003                 COMPARE s0[gs_major], 03[gs_major_gameend] ; are we in gameend?
 0B3  32123                 JUMP Z, 123[draw_gameend]                  ; do drawing for gameend
 0B4  25000                 RETURN                                     ; return
 0B5  2D009  draw_gs_debug: OUTPUT s0[gs_major], 09[leds_hi]           ; debug display on leds
 0B6  2D108                 OUTPUT s1[gs_minor], 08[leds_lo]           ; debug display on leds
 0B7  25000                 RETURN                                     ; return
 0B8  01992   draw_attrone: LOAD s9[xpos], 92                          ; draw letter A
 0B9  01A57                 LOAD sA[ypos], 57
 0BA  2015D                 CALL 15D[moveto]
 0BB  01994                 LOAD s9[xpos], 94                          ; 1
 0BC  01A57                 LOAD sA[ypos], 57
 0BD  20160                 CALL 160[drawto]
 0BE  0199D                 LOAD s9[xpos], 9D                          ; 2
 0BF  01A75                 LOAD sA[ypos], 75
 0C0  20160                 CALL 160[drawto]
 0C1  0199B                 LOAD s9[xpos], 9B                          ; 3
 0C2  01A75                 LOAD sA[ypos], 75
 0C3  20160                 CALL 160[drawto]
 0C4  0199C                 LOAD s9[xpos], 9C                          ; 4
 0C5  01A72                 LOAD sA[ypos], 72
 0C6  20160                 CALL 160[drawto]
 0C7  0198C                 LOAD s9[xpos], 8C                          ; 5
 0C8  01A72                 LOAD sA[ypos], 72
 0C9  20160                 CALL 160[drawto]
 0CA  0198B                 LOAD s9[xpos], 8B                          ; 6
 0CB  01A75                 LOAD sA[ypos], 75
 0CC  20160                 CALL 160[drawto]
 0CD  01989                 LOAD s9[xpos], 89                          ; 7
 0CE  01A75                 LOAD sA[ypos], 75
 0CF  20160                 CALL 160[drawto]
 0D0  01992                 LOAD s9[xpos], 92                          ; 8
 0D1  01A75                 LOAD sA[ypos], 75
 0D2  20160                 CALL 160[drawto]
 0D3  0198D                 LOAD s9[xpos], 8D                          ; drawing inside of A
 0D4  01A66                 LOAD sA[ypos], 66
 0D5  2015D                 CALL 15D[moveto]
 0D6  01993                 LOAD s9[xpos], 93                          ; 9
 0D7  01A59                 LOAD sA[ypos], 59
 0D8  20160                 CALL 160[drawto]
 0D9  01999                 LOAD s9[xpos], 99                          ; 10
 0DA  01A66                 LOAD sA[ypos], 66
 0DB  20160                 CALL 160[drawto]
 0DC  0198D                 LOAD s9[xpos], 8D                          ; 11
 0DD  01A66                 LOAD sA[ypos], 66
 0DE  20160                 CALL 160[drawto]
 0DF  25000                 RETURN 
 0E0  01978   draw_attrtwo: LOAD s9[xpos], 78                          ; draw letter e
 0E1  01A90                 LOAD sA[ypos], 90
 0E2  2015D                 CALL 15D[moveto]
 0E3  01958                 LOAD s9[xpos], 58
 0E4  01A90                 LOAD sA[ypos], 90
 0E5  20160                 CALL 160[drawto]
 0E6  01958                 LOAD s9[xpos], 58
 0E7  01A70                 LOAD sA[ypos], 70
 0E8  20160                 CALL 160[drawto]
 0E9  01978                 LOAD s9[xpos], 78
 0EA  01A70                 LOAD sA[ypos], 70
 0EB  20160                 CALL 160[drawto]
 0EC  01958                 LOAD s9[xpos], 58
 0ED  01A90                 LOAD sA[ypos], 90
 0EE  20160                 CALL 160[drawto]
 0EF  019A8                 LOAD s9[xpos], A8                          ; draw letter c
 0F0  01A70                 LOAD sA[ypos], 70
 0F1  2015D                 CALL 15D[moveto]
 0F2  01988                 LOAD s9[xpos], 88
 0F3  01A70                 LOAD sA[ypos], 70
 0F4  20160                 CALL 160[drawto]
 0F5  01988                 LOAD s9[xpos], 88
 0F6  01A90                 LOAD sA[ypos], 90
 0F7  20160                 CALL 160[drawto]
 0F8  019A8                 LOAD s9[xpos], A8
 0F9  01A90                 LOAD sA[ypos], 90
 0FA  20160                 CALL 160[drawto]
 0FB  25000                 RETURN 
 0FC  00920   draw_playing: LOAD s9[xpos], s2[gs_ballx]                ; draw ball
 0FD  00A30                 LOAD sA[ypos], s3[gs_bally]
 0FE  2015D                 CALL 15D[moveto]
 0FF  00920                 LOAD s9[xpos], s2[gs_ballx]
 100  00A30                 LOAD sA[ypos], s3[gs_bally]
 101  11A08                 ADD sA[ypos], 08[gs_ball_ydim]
 102  20160                 CALL 160[drawto]
 103  00920                 LOAD s9[xpos], s2[gs_ballx]
 104  00A30                 LOAD sA[ypos], s3[gs_bally]
 105  11908                 ADD s9[xpos], 08[gs_ball_xdim]
 106  11A08                 ADD sA[ypos], 08[gs_ball_ydim]
 107  20160                 CALL 160[drawto]
 108  00920                 LOAD s9[xpos], s2[gs_ballx]
 109  00A30                 LOAD sA[ypos], s3[gs_bally]
 10A  11908                 ADD s9[xpos], 08[gs_ball_xdim]
 10B  20160                 CALL 160[drawto]
 10C  00920                 LOAD s9[xpos], s2[gs_ballx]
 10D  00A30                 LOAD sA[ypos], s3[gs_bally]
 10E  20160                 CALL 160[drawto]
 10F  00960                 LOAD s9[xpos], s6[gs_padlx]                ; draw padl
 110  01AD0                 LOAD sA[ypos], D0[gs_padly]
 111  2015D                 CALL 15D[moveto]
 112  00960                 LOAD s9[xpos], s6[gs_padlx]
 113  01AD0                 LOAD sA[ypos], D0[gs_padly]
 114  11A08                 ADD sA[ypos], 08[gs_padl_ydim]
 115  20160                 CALL 160[drawto]
 116  00960                 LOAD s9[xpos], s6[gs_padlx]
 117  01AD0                 LOAD sA[ypos], D0[gs_padly]
 118  11920                 ADD s9[xpos], 20[gs_padl_xdim]
 119  11A08                 ADD sA[ypos], 08[gs_padl_ydim]
 11A  20160                 CALL 160[drawto]
 11B  00960                 LOAD s9[xpos], s6[gs_padlx]
 11C  01AD0                 LOAD sA[ypos], D0[gs_padly]
 11D  11920                 ADD s9[xpos], 20[gs_padl_xdim]
 11E  20160                 CALL 160[drawto]
 11F  00960                 LOAD s9[xpos], s6[gs_padlx]
 120  01AD0                 LOAD sA[ypos], D0[gs_padly]
 121  20160                 CALL 160[drawto]
 122  25000                 RETURN 
 123  01948   draw_gameend: LOAD s9[xpos], 48                          ; draw letter d
 124  01A50                 LOAD sA[ypos], 50
 125  2015D                 CALL 15D[moveto]
 126  01948                 LOAD s9[xpos], 48
 127  01A90                 LOAD sA[ypos], 90
 128  20160                 CALL 160[drawto]
 129  01928                 LOAD s9[xpos], 28
 12A  01A90                 LOAD sA[ypos], 90
 12B  20160                 CALL 160[drawto]
 12C  01928                 LOAD s9[xpos], 28
 12D  01A70                 LOAD sA[ypos], 70
 12E  20160                 CALL 160[drawto]
 12F  01948                 LOAD s9[xpos], 48
 130  01A70                 LOAD sA[ypos], 70
 131  20160                 CALL 160[drawto]
 132  01958                 LOAD s9[xpos], 58                          ; draw letter o
 133  01A70                 LOAD sA[ypos], 70
 134  2015D                 CALL 15D[moveto]
 135  01958                 LOAD s9[xpos], 58
 136  01A90                 LOAD sA[ypos], 90
 137  20160                 CALL 160[drawto]
 138  01978                 LOAD s9[xpos], 78
 139  01A90                 LOAD sA[ypos], 90
 13A  20160                 CALL 160[drawto]
 13B  01978                 LOAD s9[xpos], 78
 13C  01A70                 LOAD sA[ypos], 70
 13D  20160                 CALL 160[drawto]
 13E  01958                 LOAD s9[xpos], 58
 13F  01A70                 LOAD sA[ypos], 70
 140  20160                 CALL 160[drawto]
 141  01988                 LOAD s9[xpos], 88                          ; draw letter n
 142  01A90                 LOAD sA[ypos], 90
 143  2015D                 CALL 15D[moveto]
 144  01988                 LOAD s9[xpos], 88
 145  01A70                 LOAD sA[ypos], 70
 146  20160                 CALL 160[drawto]
 147  019A8                 LOAD s9[xpos], A8
 148  01A70                 LOAD sA[ypos], 70
 149  20160                 CALL 160[drawto]
 14A  019A8                 LOAD s9[xpos], A8
 14B  01A90                 LOAD sA[ypos], 90
 14C  20160                 CALL 160[drawto]
 14D  019D8                 LOAD s9[xpos], D8                          ; draw letter e
 14E  01A90                 LOAD sA[ypos], 90
 14F  2015D                 CALL 15D[moveto]
 150  019B8                 LOAD s9[xpos], B8
 151  01A90                 LOAD sA[ypos], 90
 152  20160                 CALL 160[drawto]
 153  019B8                 LOAD s9[xpos], B8
 154  01A70                 LOAD sA[ypos], 70
 155  20160                 CALL 160[drawto]
 156  019D8                 LOAD s9[xpos], D8
 157  01A70                 LOAD sA[ypos], 70
 158  20160                 CALL 160[drawto]
 159  019B8                 LOAD s9[xpos], B8
 15A  01A90                 LOAD sA[ypos], 90
 15B  20160                 CALL 160[drawto]
 15C  25000                 RETURN 
 15D                        ;;============================================================================
 15D                        ;; Subroutine: moveto and drawto
 15D                        ;; The moveto routine uses the global variables xpos and ypos, and the drawto
 15D                        ;; routine uses these global variables as well as the endpoint coordinates in
 15D                        ;; the display controller.  Moveto simply copies xpos and ypos into endpoint
 15D                        ;; coordinates in the display controller, it does not draw anything.  The
 15D                        ;; drawto routine copies endpoint coordinates to startpoint coordinates (does
 15D                        ;; not matter if the endpoint was from an actual draw, or simply an update
 15D                        ;; by moveto) and then copies xpos and ypos into endpoint coordinates, then
 15D                        ;; starts a linedraw.
 15D                        ;;============================================================================
 15D  2D902         moveto: OUTPUT s9[xpos], 02[endx]                  ; copy global to hardware
 15E  2DA03                 OUTPUT sA[ypos], 03[endy]                  ; copy global to hardware
 15F  25000                 RETURN                                     ; return
 160  09F02         drawto: INPUT sF[scratch], 02[endx]                ; read hardware
 161  2DF00                 OUTPUT sF[scratch], 00[stax]               ; write hardware
 162  2D902                 OUTPUT s9[xpos], 02[endx]                  ; copy global to hardware
 163  09F03                 INPUT sF[scratch], 03[endy]                ; read hardware
 164  2DF01                 OUTPUT sF[scratch], 01[stay]               ; write hardware
 165  2DA03                 OUTPUT sA[ypos], 03[endy]                  ; copy global to hardware
 166  01F01                 LOAD sF[scratch], 01[busy_go]              ; prepare the command
 167  2DF04                 OUTPUT sF[scratch], 04[busy]               ; send the command
 168  20012                 CALL 012[hw_init_wait]                     ; wait line draw done
 169  25000                 RETURN                                     ; return
 16A                        ;;============================================================================
 16A                        ;; Interrupt - Vector.
 16A                        ;;============================================================================
 7FF                        ADDRESS 7FF                                ; must be located here
 7FF  22004     isr_vector: JUMP 004[isr]                              ; always jump to isr
 800                        ;;============================================================================
 800                        ;;
 800                        ;;============================================================================



List of PSM files that have been assembled

C:\Users\daime\OneDrive\Documents\School\Semester 9\EE 178\SpaceInvaders\FPGA_Space_Invaders\software\SOFTWARECOPY.PSM



List of defined constants

 CONSTANT name     Value        Source PSM File

 timestamp_hours   18'd         
 timestamp_minutes 51'd         
 timestamp_seconds 54'd         
 datestamp_year    16'd         
 datestamp_month   12'd         
 datestamp_day     06'd         
 NUL               00           
 BEL               07           
 BS                08           
 HT                09           
 LF                0A           
 VT                0B           
 CR                0D           
 ESC               1B           
 DEL               7F           
 DCS               90           
 ST                9C           
 stax              00           SOFTWARECOPY.PSM
 stay              01           SOFTWARECOPY.PSM
 endx              02           SOFTWARECOPY.PSM
 endy              03           SOFTWARECOPY.PSM
 busy              04           SOFTWARECOPY.PSM
 beam              05           SOFTWARECOPY.PSM
 mode              06           SOFTWARECOPY.PSM
 prng              07           SOFTWARECOPY.PSM
 leds_lo           08           SOFTWARECOPY.PSM
 leds_hi           09           SOFTWARECOPY.PSM
 qssd_lo           0A           SOFTWARECOPY.PSM
 qssd_hi           0B           SOFTWARECOPY.PSM
 qssd_dp           0C           SOFTWARECOPY.PSM
 switches_lo       0D           SOFTWARECOPY.PSM
 switches_hi       0E           SOFTWARECOPY.PSM
 buttons           0F           SOFTWARECOPY.PSM
 busy_go           01           SOFTWARECOPY.PSM
 beam_hi           0F           SOFTWARECOPY.PSM
 beam_md           07           SOFTWARECOPY.PSM
 beam_lo           03           SOFTWARECOPY.PSM
 mode_hld          00           SOFTWARECOPY.PSM
 mode_clr          01           SOFTWARECOPY.PSM
 mode_lin          02           SOFTWARECOPY.PSM
 mode_exp          03           SOFTWARECOPY.PSM
 buttons_ct        10           SOFTWARECOPY.PSM
 buttons_up        08           SOFTWARECOPY.PSM
 buttons_dn        04           SOFTWARECOPY.PSM
 buttons_lf        02           SOFTWARECOPY.PSM
 buttons_rt        01           SOFTWARECOPY.PSM
 gs_major_attrone  00           SOFTWARECOPY.PSM
 gs_major_attrtwo  01           SOFTWARECOPY.PSM
 gs_major_playing  02           SOFTWARECOPY.PSM
 gs_major_gameend  03           SOFTWARECOPY.PSM
 gs_minor_begins   00           SOFTWARECOPY.PSM
 gs_minor_twosec   78           SOFTWARECOPY.PSM
 gs_minor_onesec   3C           SOFTWARECOPY.PSM
 gs_minor_getrdy   1E           SOFTWARECOPY.PSM
 gs_ball_xdim      08           SOFTWARECOPY.PSM
 gs_ball_ydim      08           SOFTWARECOPY.PSM
 gs_ball_speed     03           SOFTWARECOPY.PSM
 gs_padly          D0           SOFTWARECOPY.PSM
 gs_padl_xdim      20           SOFTWARECOPY.PSM
 gs_padl_ydim      08           SOFTWARECOPY.PSM
 gs_padl_speed     04           SOFTWARECOPY.PSM
 minusone          FF           SOFTWARECOPY.PSM
 minusmax          80           SOFTWARECOPY.PSM
 plusmax           7F           SOFTWARECOPY.PSM
 zero              00           SOFTWARECOPY.PSM
 one               01           SOFTWARECOPY.PSM



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.51"        
 datestamp$        "06 Dec 2016"  
 timestamp$        "18:51:54"     



List of line labels

   Label           Addr  Source PSM File

 * boot            000   SOFTWARECOPY.PSM
   main            003   SOFTWARECOPY.PSM
   isr             004   SOFTWARECOPY.PSM
   hw_init         008   SOFTWARECOPY.PSM
   hw_init_wait    012   SOFTWARECOPY.PSM
   gs_init         016   SOFTWARECOPY.PSM
   user_input      01E   SOFTWARECOPY.PSM
   ram_example     023   SOFTWARECOPY.PSM
   calc_next_gs    02A   SOFTWARECOPY.PSM
   calc_attrone    033   SOFTWARECOPY.PSM
   calc_attrtwo    039   SOFTWARECOPY.PSM
   calc_playing    03F   SOFTWARECOPY.PSM
 * getrdy          042   SOFTWARECOPY.PSM
   goplay          044   SOFTWARECOPY.PSM
   upd_padl        049   SOFTWARECOPY.PSM
   upd_padl_lt     053   SOFTWARECOPY.PSM
   upd_padl_rt     057   SOFTWARECOPY.PSM
   upd_ball        05E   SOFTWARECOPY.PSM
   upd_ball_loop   05F   SOFTWARECOPY.PSM
 * upd_ball_step   061   SOFTWARECOPY.PSM
 * upd_ball_padl   063   SOFTWARECOPY.PSM
   upd_ball_lw     070   SOFTWARECOPY.PSM
   upd_ball_tw     073   SOFTWARECOPY.PSM
   upd_ball_rw     076   SOFTWARECOPY.PSM
   upd_ball_bw     07B   SOFTWARECOPY.PSM
   upd_ball_done   081   SOFTWARECOPY.PSM
   calc_gameend    082   SOFTWARECOPY.PSM
   goto_attrone    086   SOFTWARECOPY.PSM
   goto_attrtwo    089   SOFTWARECOPY.PSM
   goto_playing    08C   SOFTWARECOPY.PSM
 * balldxsta       09B   SOFTWARECOPY.PSM
 * balldxneg       09E   SOFTWARECOPY.PSM
   balldxpos       0A0   SOFTWARECOPY.PSM
   balldysta       0A1   SOFTWARECOPY.PSM
 * balldyneg       0A4   SOFTWARECOPY.PSM
   balldypos       0A6   SOFTWARECOPY.PSM
   ballddone       0A7   SOFTWARECOPY.PSM
   goto_gameend    0A8   SOFTWARECOPY.PSM
   draw_gs         0AB   SOFTWARECOPY.PSM
   draw_gs_debug   0B5   SOFTWARECOPY.PSM
   draw_attrone    0B8   SOFTWARECOPY.PSM
   draw_attrtwo    0E0   SOFTWARECOPY.PSM
   draw_playing    0FC   SOFTWARECOPY.PSM
   draw_gameend    123   SOFTWARECOPY.PSM
   moveto          15D   SOFTWARECOPY.PSM
   drawto          160   SOFTWARECOPY.PSM
 * isr_vector      7FF   SOFTWARECOPY.PSM

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            142
 STAR              -

 AND               -
 OR                -
 XOR               1

 ADD              22
 ADDCY             1
 SUB               6
 SUBCY             1

 TEST              7
 TESTCY            -
 COMPARE          23
 COMPARECY         1

 SL0               -
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               -
 SR1               -
 SRX               5
 SRA               -
 RR                -

 REGBANK           -

 INPUT            10
 OUTPUT           18
 OUTPUTK           -

 STORE             1
 FETCH             1

 DISABLE           -
 ENABLE            1
 RETURNI           1

 JUMP             30
 JUMP@             -
 CALL             63
 CALL@             -
 RETURN           29
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
